<!DOCTYPE html><html lang="ch" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>面试题 | YaYa blogs</title><meta name="author" content="YaYa"><meta name="copyright" content="YaYa"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.说说你对盒子模型的理解当对一个文档进行布局的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型，将所有元素表示为一个个矩形的盒子 这个盒子就是盒模型 一个盒子由四个部分组成：content(实际内容) padding(内边距) border(边框) margin(外边距) 盒子模型可以分为W3C标准盒子模型 IE怪异盒子模型 标准盒子模型，是浏览器默认的盒子模型 width&amp;#x2F">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="http://example.com/2022/11/16/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="YaYa blogs">
<meta property="og:description" content="1.说说你对盒子模型的理解当对一个文档进行布局的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型，将所有元素表示为一个个矩形的盒子 这个盒子就是盒模型 一个盒子由四个部分组成：content(实际内容) padding(内边距) border(边框) margin(外边距) 盒子模型可以分为W3C标准盒子模型 IE怪异盒子模型 标准盒子模型，是浏览器默认的盒子模型 width&amp;#x2F">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/img/head.jpg">
<meta property="article:published_time" content="2022-11-16T03:51:17.000Z">
<meta property="article:modified_time" content="2023-01-05T02:26:40.516Z">
<meta property="article:author" content="YaYa">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/head.jpg"><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="http://example.com/2022/11/16/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-05 10:26:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/transpancy.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-serch"></i><span> 搜索</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">YaYa blogs</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-serch"></i><span> 搜索</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-11-16T03:51:17.000Z" title="Created 2022-11-16 11:51:17">2022-11-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-01-05T02:26:40.516Z" title="Updated 2023-01-05 10:26:40">2023-01-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="1-说说你对盒子模型的理解"><a href="#1-说说你对盒子模型的理解" class="headerlink" title="1.说说你对盒子模型的理解"></a>1.说说你对盒子模型的理解</h2><p>当对一个文档进行布局的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型，将所有元素表示为一个个矩形的盒子 这个盒子就是盒模型 一个盒子由四个部分组成：content(实际内容) padding(内边距) border(边框) margin(外边距) 盒子模型可以分为W3C标准盒子模型 IE怪异盒子模型 标准盒子模型，是浏览器默认的盒子模型 width&#x2F;height 只是内容高度，不包含 padding 和 border值 怪异盒子模型 width&#x2F;height 包含了 padding和 border值</p>
<h2 id="2-css选择器有哪些？优先级？哪些属性可以继承？"><a href="#2-css选择器有哪些？优先级？哪些属性可以继承？" class="headerlink" title="2.css选择器有哪些？优先级？哪些属性可以继承？"></a>2.css选择器有哪些？优先级？哪些属性可以继承？</h2><p>Id选择器 类选择器 标签选择器 后代选择器 子选择器 相邻同胞选择器 群组选择器 伪类选择器 伪元素选择器 属性选择器<br>优先级：内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器<br>继承：文本系列属性 元素可见性 表格布局属性 列表属性 引用 光标属性font组合字体 text-indent text-align line-height visibility caption-side </p>
<h2 id="3-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"><a href="#3-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？" class="headerlink" title="3.元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"></a>3.元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</h2><p>定位+margin:auto：父级设置相对定位 子级绝对定位 如果子级没有宽高就会被拉开父级一样的宽高 如果设置了宽高 给他一个margin:auto就可以了<br>定位+margin:负值：设置父元素为相对定位， 子元素移动自身50%实现水平垂直居中<br>定位+transform：是margin负值的替代方案，并不需要知道自身元素的宽高<br>Table布局：设置父元素为display:table-cell，子元素设置 display: inline-block。利用vertical和text-align可以让所有的行内块级元素水平垂直居中<br>Flex弹性布局<br>Gird网格布局<br>不定宽高：定位+margin:auto 定位+transform</p>
<h2 id="4-怎么理解回流跟重绘？什么场景下会触发？"><a href="#4-怎么理解回流跟重绘？什么场景下会触发？" class="headerlink" title="4.怎么理解回流跟重绘？什么场景下会触发？"></a>4.怎么理解回流跟重绘？什么场景下会触发？</h2><p>回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置<br>重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制<br>回流场景：添加或删除可见的DOM元素 元素的位置发生变化 元素的尺寸发生变化 页面一开始渲染的时候 浏览器的窗口尺寸变化<br>重绘场景：触发回流一定会触发重绘 颜色的修改 文本方向的修改 阴影的修改</p>
<h2 id="5-什么是响应式设计？响应式设计的基本原理是什么？如何做？"><a href="#5-什么是响应式设计？响应式设计的基本原理是什么？如何做？" class="headerlink" title="5.什么是响应式设计？响应式设计的基本原理是什么？如何做？"></a>5.什么是响应式设计？响应式设计的基本原理是什么？如何做？</h2><p>响应式网站设计是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境进行相应的响应和调整<br>基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有meta声明viewport<br>媒体查询、百分比、vw&#x2F;vh、rem</p>
<h2 id="6-如果要做优化，CSS提高性能的方法有哪些？"><a href="#6-如果要做优化，CSS提高性能的方法有哪些？" class="headerlink" title="6.如果要做优化，CSS提高性能的方法有哪些？"></a>6.如果要做优化，CSS提高性能的方法有哪些？</h2><p>内联首屏关键CSS、异步加载CSS、资源压缩、合理使用选择器、减少使用昂贵的属性、不使用@import</p>
<h2 id="7-对前端工程师这个职位是怎么样理解的？它的前景会怎么样"><a href="#7-对前端工程师这个职位是怎么样理解的？它的前景会怎么样" class="headerlink" title="7.对前端工程师这个职位是怎么样理解的？它的前景会怎么样"></a>7.对前端工程师这个职位是怎么样理解的？它的前景会怎么样</h2><p>……</p>
<h2 id="8-说说JavaScript中的数据类型？存储上的差别？"><a href="#8-说说JavaScript中的数据类型？存储上的差别？" class="headerlink" title="8.说说JavaScript中的数据类型？存储上的差别？"></a>8.说说JavaScript中的数据类型？存储上的差别？</h2><p>分为基本类型和复杂类型<br>基本类型包含Number、String、Boolean、Undefined、null、symbol<br>复杂类型包含Object、Array、Function<br>声明变量时不同的内存地址分配：简单类型的值存放在栈中 存放的是对应的值、引用类型对应的值存储在堆中 在栈中存放的是指向堆内存的地址<br>不同的类型数据导致赋值变量时的不同：简单类型赋值，是生成相同的值，两个对象对应不同的地址、复杂类型赋值，是将保存对象的内存地址赋值给另一个变量</p>
<h2 id="9-typeof-与-instanceof-区别"><a href="#9-typeof-与-instanceof-区别" class="headerlink" title="9.typeof 与 instanceof 区别"></a>9.typeof 与 instanceof 区别</h2><p>typeof 是判断数据类型的一个方法 操作符返回一个字符串，表示未经计算的操作数的类型<br>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上<br>区别：typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值、instanceof可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型、而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断显示的都是object</p>
<h2 id="10-说说你对闭包的理解？闭包使用场景"><a href="#10-说说你对闭包的理解？闭包使用场景" class="headerlink" title="10.说说你对闭包的理解？闭包使用场景"></a>10.说说你对闭包的理解？闭包使用场景</h2><p>一个函数和对其周围状态的引用捆绑在一起或者说函数被引用包围，这样的组合就是闭包 闭包让你可以在一个内层函数中访问到其外层函数的作用域<br>使用场景：创建私有变量、延长变量的生命周期</p>
<h2 id="11-bind、call、apply-区别？如何实现一个bind"><a href="#11-bind、call、apply-区别？如何实现一个bind" class="headerlink" title="11.bind、call、apply 区别？如何实现一个bind?"></a>11.bind、call、apply 区别？如何实现一个bind?</h2><p>三者都可以改变函数的this对象指向<br>三者第一个参数都是this要指向的对象，如果没有这个参数或参数为undefined或null，则默认指向全局window<br>三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入<br>Bind是返回绑定this之后的函数，apply、call 则是立即执行<br> bind的三个特点 (1)保存this,返回新的函数 (2)可以传入参数 (3)一个绑定函数也可以使用new操作符创建对象</p>
<h2 id="12-说说你对事件循环的理解"><a href="#12-说说你对事件循环的理解" class="headerlink" title="12.说说你对事件循环的理解"></a>12.说说你对事件循环的理解</h2><p>同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行 上述过程的不断重复就事件循环<br>事件循环分为宏任务和微任务<br>微任务：一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前 常见的有：Promise.then MutationObserver process.nextTick<br>常见宏任务有：script setTimeout&#x2F;setInterval UI rendering postMessage MessageChannel setImmediate I&#x2F;O</p>
<p>前端开发中我们会通过 setTimeout&#x2F;setInterval 来指定定时务，会通过 XHR&#x2F;fetch 发送网络请求<br>。接下来简述一下 setTimeout&#x2F;setInterva1和 XHR&#x2F;fetch 到底做了什么事我们知道，不管是setTimeout&#x2F;setinterval 和 XHR&#x2F;fetch代码，在这些代码执行时，本身是同步任务，而其中的回调函数才是异步任务<br>当代码执行到 setTimeout&#x2F;setInterva1时，实际上是S引擎线程通知 定时触发器线程，间隔一个时间后，会触发一个回调事件<br>而定时触发器线程在接收到这个消息后，会在等待的时间后，将回调事件放入到由 事件触发线程所管理的事件队列中当代码执行到 XHR&#x2F;fetch 时，实际上是JS引擎线程通知 异步http 请求线程，发送一个网络请求，并制定请求完成后的回调事件<br>而异步http 请求线程在接收到这个消息后，会在请求成功后，将回调事件放入到由 事件触发线程所管理的 事件队列中当我们的同步任务执行完，，Js 引擎线程会询问事件触发线程，在 事件队列中是否有待执行的回调函数，如果有就会加入到执行栈中交给IS引擎线程执行<br>.<br>0<br>结<br>。IS引擎线程只执行执行栈中的事件<br>。执行栈中的代码执行完毕，就会读取事件队列中的事件.事件队列中的回调事件，是由各自线程插入到事件队列中的<br>。如此循环                                                                                             </p>
<h2 id="13-DOM常见的操作有哪些"><a href="#13-DOM常见的操作有哪些" class="headerlink" title="13.DOM常见的操作有哪些"></a>13.DOM常见的操作有哪些</h2><p>创建节点：createElement、createTextNode、createDocumentFragment、createAttribute<br>查询节点：querySelector、querySelectorAll<br>更新节点：innerHTML、innerText、textContent、style<br>添加节点：innerHTML、appendChild、insertBefore、setAttribute<br>删除节点：removeChild</p>
<h2 id="14-说说你对BOM的理解，常见的BOM对象你了解哪些？"><a href="#14-说说你对BOM的理解，常见的BOM对象你了解哪些？" class="headerlink" title="14.说说你对BOM的理解，常见的BOM对象你了解哪些？"></a>14.说说你对BOM的理解，常见的BOM对象你了解哪些？</h2><p>BOM是浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象 其作用就是跟浏览器做一些交互效果,比如如何进行页面的后退，前进，刷新，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息 Bom的核心对象是window，它表示浏览器的一个实例<br>常见的BOM对象：window、location、navigator、screen、history</p>
<h2 id="15-Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#15-Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="15.Javascript本地存储的方式有哪些？区别及应用场景？"></a>15.Javascript本地存储的方式有哪些？区别及应用场景？</h2><p>Cookie、sessionStorage、localStorage、indexedDB<br>区别：<br>存储大小：cookie数据大小不能超过4k，sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多<br>有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage数据在当前浏览器窗口关闭后自动删除；cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭<br>数据与服务器之间的交互方式：cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端； sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存<br>场景：<br>标记用户与跟踪用户行为的情况，推荐使用cookie<br>适合长期保存在本地的数据（令牌），推荐使用localStorage<br>敏感账号一次性登录，推荐使用sessionStorage<br>存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB</p>
<h2 id="16-什么是防抖和节流？有什么区别？如何实现？"><a href="#16-什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="16.什么是防抖和节流？有什么区别？如何实现？"></a>16.什么是防抖和节流？有什么区别？如何实现？</h2><p>防抖：n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时<br>节流：n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效<br>区别：<br>函数防抖在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能<br>函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次<br>实现：<br>节流：使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行；使用定时器写法，delay毫秒后第一次执行，第二次事件停止触发后依然会再一次执行；也可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流<br>防抖：使用一个变量来判断你的每次操作时候是否已经触发过定时器了，如果触发过了就将原来触发但还没到n秒的定时器清除，接着重新来个n秒的定时器；如果没触发过说明n秒内没有进行操作，新建一个n秒的定时器就行</p>
<h2 id="17-如何通过JS判断一个数组"><a href="#17-如何通过JS判断一个数组" class="headerlink" title="17.如何通过JS判断一个数组"></a>17.如何通过JS判断一个数组</h2><p>通过instanceof判断：instanceof运算符用于检验构造函数的prototype属性是否出现在对象的原型链中的任何位置，返回一个布尔值<br>通过constructor判断：实例的构造函数属性constructor指向构造函数，通过constructor属性可以判断是否为一个数组<br>通过Object.prototype.toString.call()判断：Object.prototype.toString.call()可以获取到对象的不同类型<br>通过Array.isArray()判断：Array.isArray()用于确定传递的值是否是一个数组，返回一个布尔值</p>
<h2 id="18-说说你对作用域链的理解"><a href="#18-说说你对作用域链的理解" class="headerlink" title="18.说说你对作用域链的理解"></a>18.说说你对作用域链的理解</h2><p>作用域 即变量和函数生效的区域或集合 换句话说 作用域决定了代码区块中变量和其他资源的可见性 作用域一般分为全局作用域、函数作用域、块级作用域<br>作用域链：当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域 这就是作用域链</p>
<h2 id="19-JavaScript原型，原型链-有什么特点？"><a href="#19-JavaScript原型，原型链-有什么特点？" class="headerlink" title="19.JavaScript原型，原型链 ? 有什么特点？"></a>19.JavaScript原型，原型链 ? 有什么特点？</h2><p>原型：JS中每个函数都存在有一个原型对象属性prototype。并且所有函数的默认原型都是Object的实例<br>原型链：每个继承父函数的子函数的对象都包含一个内部属性_proto_。该属性包含一个指针，指向父函数的prototype。若父函数的原型对象的_proto_属性为再上一层函数。在此过程中就形成了原型链。<br>特点：原型链实现了继承。原型链存在两个问题：包含引用类型值的原型属性会被所有实例共享；在创建子类型时，无法向超类型的构造函数中传递参数</p>
<h2 id="20-请解释什么是事件代理"><a href="#20-请解释什么是事件代理" class="headerlink" title="20.请解释什么是事件代理"></a>20.请解释什么是事件代理</h2><p>事件代理，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素 事件流的都会经过三个阶段： 捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段，而事件委托就是在冒泡阶段完成</p>
<h2 id="21-谈谈This对象的理解"><a href="#21-谈谈This对象的理解" class="headerlink" title="21.谈谈This对象的理解"></a>21.谈谈This对象的理解</h2><p>this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象 在绝大多数情况下，函数的调用方式决定了 this 的值 同时，this在函数执行过程中，this一旦被确定了，就不可以再更改<br>根据不同的场合 this有不同的值：默认绑定（严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象） 隐式绑定（函数可以作为某个对象的方法调用，这时this就指这个上级对象） new绑定（通过构建函数new关键字生成一个实例对象，此时this指向这个实例对象）</p>
<h2 id="22-new操作符具体干了什么"><a href="#22-new操作符具体干了什么" class="headerlink" title="22.new操作符具体干了什么"></a>22.new操作符具体干了什么</h2><p>在JavaScript中，new操作符用于创建一个给定构造函数的实例对象<br>new 通过构造函数创建出来的实例可以访问到构造函数中的属性<br>new 通过构造函数创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来）<br>创建一个新的对象<br>将构建函数中的this绑定到新建的对象上<br>根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理</p>
<p>new 经历了四个过程 </p>
<p>var fn &#x3D; function () f 1;var fnObj &#x3D; new fn();<br>1 创建了一个空对象<br>var obi &#x3D; new object();<br>2 设置 原型链Q2.<br>obj. proto  &#x3D; fn.prototype;<br>3、让fn的this指向obj，并执行fn的函数体<br>var result &#x3D; fn.call(obi);<br>4、判断fn的返回值类型，如果是值类型，返回obi。如果是引用类型，就返回这个引用类型的对象,<br>if (typeof(result) &#x3D;&#x3D; “object”)[fnObi &#x3D; result;l else !<br>fnobj &#x3D; obj;</p>
<p>}</p>
<h2 id="23-null，undefined-的区别"><a href="#23-null，undefined-的区别" class="headerlink" title="23.null，undefined 的区别"></a>23.null，undefined 的区别</h2><p>Null是空值 undefined是未定义的值<br>数据类型不同null的类型是object    undefined的类型是undefined<br>null和undefined两者相等，但是当两者做全等比较时，两者又不等<br>转化成数字 null是0 undefined是NaN<br>undefined是表示变量声明过但并未赋过值，它是所有未赋值变量默认值<br>null表示一个变量将来可能指向一个对象，一般用于主动释放指向对象的引用</p>
<h2 id="24-javascript-代码中的”use-strict”-是什么意思"><a href="#24-javascript-代码中的”use-strict”-是什么意思" class="headerlink" title="24.javascript 代码中的”use strict”;是什么意思"></a>24.javascript 代码中的”use strict”;是什么意思</h2><p>“use strict”;是一个字符串字面量，用来指定代码运行于严格模式下 严格模式下你不能使用未声明的变量 “严格模式”体现了Javascript更合理、更安全、更严谨的发展方向 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行</p>
<h2 id="25-同步和异步的区别"><a href="#25-同步和异步的区别" class="headerlink" title="25.同步和异步的区别"></a>25.同步和异步的区别</h2><p>同步：同步是指一个进程在执行某个请求的时候，如果该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去<br>异步：异步是指进程不需要一直等待下去，而是继续执行下面的操作，不管其他进程的状态，当有信息返回的时候会通知进程进行处理，这样就可以提高执行的效率了<br>如果是ajax去局部请求数据，也不一定都是适合使用异步的，比如应用程序往下执行时以来从服务器请求的数据，那么必须等这个数据返回才行，这时必须使用同步。而发送邮件的时候，采用异步发送就可以了，因为不论花了多长时间，对方能收到就好。总结得来说，就是看需要请求的数据是否是程序继续执行必须依赖的数据</p>
<h2 id="26-谈一谈箭头函数与普通函数的区别"><a href="#26-谈一谈箭头函数与普通函数的区别" class="headerlink" title="26.谈一谈箭头函数与普通函数的区别"></a>26.谈一谈箭头函数与普通函数的区别</h2><p>外形不同：箭头函数使用箭头定义，普通函数中没有。<br>箭头函数全都是匿名函数：普通函数可以有匿名函数，也可以有具名函数<br>箭头函数不能用于构造函数：普通函数可以用于构造函数，以此创建对象实例。<br>箭头函数中 this 的指向不同：在普通函数中，this 总是指向调用它的对象，如果用作构造函数，它指向创建的对象实例。<br>箭头函数不具有 arguments 对象：每一个普通函数调用后都具有一个arguments 对象，用来存储实际传递的参数。但是箭头函数并没有此对象。<br>其他区别：箭头函数不具有 prototype 原型对象。箭头函数不具有 super。<br>箭头函数不具有 new.target</p>
<h2 id="27-JS-数组和对象的遍历方式，以及几种方式的比较、"><a href="#27-JS-数组和对象的遍历方式，以及几种方式的比较、" class="headerlink" title="27.JS 数组和对象的遍历方式，以及几种方式的比较、"></a>27.JS 数组和对象的遍历方式，以及几种方式的比较、</h2><p>遍历数组方式：for in循环、for循环、forEach（forEach 无法遍历对象）、map、for of循环（ES6新增方法）<br>遍历对象：for…in…（遍历的是对象的键名）、Object.keys（会返回一个由一个指定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用for…in循环遍历该对象时返回的顺序一致）、Object.getOwnPropertyNames(obj)（返回一个数组，包含对象自身的所有属性（包含不可枚举属性） 结合forEach遍历可以获取key和value）<br>比较：<br>for…in 遍历（当前对象及其原型上的）每一个key,而 for…of遍历（当前对象上的）每一个value;<br>for in 以任意顺序遍历对象的可枚举属性（最好不要用来遍历数组）因此当迭代那些访问次序重要的 arrays 时用整数索引去进行 for 循环 (或者使用 Array.prototype.forEach() 或 for…of 循环)<br>for…of 允许遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等 但不能单独来遍历对象，要结合Object.keys一起使用才行</p>
<h2 id="28-如何解决跨域问题"><a href="#28-如何解决跨域问题" class="headerlink" title="28.如何解决跨域问题"></a>28.如何解决跨域问题</h2><p>跨域本质是浏览器基于同源策略的一种安全手段<br>同源策略是一种约定，它是浏览器最核心也最基本的安全功能 所谓同源（即指在同一个域）具有以下三个相同点：协议相同（protocol）、主机相同（host）、端口相同（port）反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域 一定要注意跨域是浏览器的限制<br>解决：JSONP(通过script标签)   、CORS（是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应 CORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允许的访问来源 只要后端实现了 CORS，就实现了跨域）、Proxy（Proxy也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接 在vue中使用时 我们可以在vue.config.js文件中新增proxy属性）</p>
<h2 id="29-XML和JSON的区别"><a href="#29-XML和JSON的区别" class="headerlink" title="29.XML和JSON的区别"></a>29.XML和JSON的区别</h2><p>xml：可扩展标记语言，是一种用于标记电子文件使其具有结构性的标记语言<br>json：(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式<br>区别：<br>它们都是一种数据交换格式<br>xml是重量级的，json是轻量级的<br>xml在传输过程中比较占带宽，json占带宽少，易于压缩<br>xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互<br>json可用jackson，gson等方法解析，xml可用dom，sax，demo4j等方式解析</p>
<h2 id="30-谈谈你对webpack的看法"><a href="#30-谈谈你对webpack的看法" class="headerlink" title="30.谈谈你对webpack的看法"></a>30.谈谈你对webpack的看法</h2><p>webpack 是一个用于现代JavaScript应用程序的静态模块打包工具 这里的静态模块指的是开发阶段，可以被 webpack 直接引用的资源 Webpack 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源<br>我们在开发过程中 可能会遇到需要通过模块化的方式来开发、使用一些高级的特性来加快我们的开发效率或者安全性、监听文件的变化来并且反映到浏览器上 提高开发效率等问题 webpack刚好就解决了这些问题</p>
<h2 id="31-webpack的打包原理"><a href="#31-webpack的打包原理" class="headerlink" title="31.webpack的打包原理"></a>31.webpack的打包原理</h2><p>webpack打包原理是将根据文件间的依赖关系对其进行静态分析，然后将这些模块按指定规则生成静态资源，当 webpack处理程序时，会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成bundle</p>
<h2 id="32-如何优化webpack打包速度"><a href="#32-如何优化webpack打包速度" class="headerlink" title="32.如何优化webpack打包速度"></a>32.如何优化webpack打包速度</h2><p>减小文件搜索范围；配置resolve.modules；设置test、include、exclude；增强代码压缩工具；用Happypack加速代码构建；拷贝静态文件</p>
<h2 id="33-说说webpack中常见的Loader？解决了什么问题？"><a href="#33-说说webpack中常见的Loader？解决了什么问题？" class="headerlink" title="33.说说webpack中常见的Loader？解决了什么问题？"></a>33.说说webpack中常见的Loader？解决了什么问题？</h2><p>Style-loader（将css添加到DOM的内联样式标签style里）、css-loader（允许将css文件通过require的方式引入，并返回css代码）、less-loader（ 处理less）、sass-loader（处理sass）、postcss-loader（用postcss来处理CSS）、file-loader（分发文件到output目录并返回相对路径）<br>Webpack仅仅是分析出各种模块的依赖关系 形成资源列表 最终打包生成指定的文件 默认情况下 在遇到import或require加载模块的时候 webpack只支持对js和json文件打包 像css、sass、less、png等文件 webpack无法进行解析 这时候就需要配置对应的loader进行文件内容的解析</p>
<h2 id="34-说说webpack中常见的Plugin？解决了什么问题？"><a href="#34-说说webpack中常见的Plugin？解决了什么问题？" class="headerlink" title="34.说说webpack中常见的Plugin？解决了什么问题？"></a>34.说说webpack中常见的Plugin？解决了什么问题？</h2><p>HtmlWebpackPlugin：简单创建html文件 用于服务器访问<br>AggressiveSplittingPlugin：将原来的chunk分成更小的chunk<br>BannerPlugin：在每个生成的chunk顶部添加banner<br>CommonsChunkPlugin：提取chunks之间共享的通用模块<br>DefinePlugin：允许在编译时配置的全局常量</p>
<h2 id="35-说说你对promise的了解"><a href="#35-说说你对promise的了解" class="headerlink" title="35.说说你对promise的了解"></a>35.说说你对promise的了解</h2><p><code>Promise</code>，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>链式操作减低了编码难度</li>
<li>代码可读性明显增强</li>
</ul>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p><code>promise</code>对象仅有三种状态</p>
<ul>
<li><code>pending</code>（进行中）</li>
<li><code>fulfilled</code>（已成功）</li>
<li><code>rejected</code>（已失败）</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li>
<li>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</li>
</ul>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例  接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code></p>
<ul>
<li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”</li>
<li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”</li>
</ul>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ul>
<li>then()<ul>
<li><code>then</code>方法返回的是一个新的<code>Promise</code>实例 ，是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</li>
</ul>
</li>
<li>catch()<ul>
<li>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数</li>
</ul>
</li>
<li>finally()<ul>
<li>不管 Promise 对象最后状态如何，都会执行的操作</li>
</ul>
</li>
</ul>
<h4 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h4><p><code>Promise</code>构造函数存在以下方法：</p>
<ul>
<li><p>all()</p>
<ul>
<li><p><code>Promise.all()</code>方法用于将多个 <code>Promise</code>实例，包装成一个新的 <code>Promise</code>实例</p>
</li>
<li><p>接受一个数组（迭代对象）作为参数，数组成员都应为<code>Promise</code>实例</p>
</li>
<li><p>实例<code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分为两种：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<ul>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</li>
<li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数</li>
</ul>
</li>
</ul>
</li>
<li><p>race()</p>
<ul>
<li>接收一个数组（迭代对象）作为参数，只要有一个实例率先改变状态，总的状态就跟着改变</li>
<li>率先改变的 Promise 实例的返回值则传递给<code>p</code>的回调函数</li>
</ul>
</li>
<li><p>allSettled()</p>
<ul>
<li><p>接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</p>
<p>只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束</p>
</li>
</ul>
</li>
<li><p>resolve()</p>
<ul>
<li>将现有对象转为 <code>Promise</code>对象</li>
<li>参数可以分成四种情况，分别如下：<ul>
<li>参数是一个 Promise 实例，<code>promise.resolve</code>将不做任何修改、原封不动地返回这个实例</li>
<li>参数是一个<code>thenable</code>对象，<code>promise.resolve</code>会将这个对象转为 <code>Promise</code>对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法</li>
<li>参数不是具有<code>then()</code>方法的对象，或根本就不是对象，<code>Promise.resolve()</code>会返回一个新的 Promise 对象，状态为<code>resolved</code></li>
<li>没有参数时，直接返回一个<code>resolved</code>状态的 Promise 对象</li>
</ul>
</li>
</ul>
</li>
<li><p>reject()</p>
<ul>
<li>返回一个新的 Promise 实例，该实例的状态为<code>rejected</code></li>
<li><code>Promise.reject()</code>方法的参数，会原封不动地变成后续方法的参数</li>
</ul>
</li>
<li><p>try()</p>
</li>
</ul>
<h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><ol>
<li>将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化</li>
<li>通过<code>all()</code>实现多个请求合并在一起，汇总所有请求结果，只需设置一个<code>loading</code>即可</li>
<li>通过<code>race</code>可以设置图片请求超时</li>
</ol>
<h2 id="36-async函数是什么，有什么作用"><a href="#36-async函数是什么，有什么作用" class="headerlink" title="36.async函数是什么，有什么作用"></a>36.async函数是什么，有什么作用</h2><p>(1)Async 函数是Generator函数的语法糖， 特点如下：	<br>①语义化更好，await 一看就知道在等待后面的操作完成<br>②实用性更广 Generator函数后面只能跟thunk函数或者promise对象，但是await就不一样了 也可以跟同步代码<br>③Generator返回的是迭代对象，而async返回的是promise对象<br>(2)Async 函数有什么作用;<br>①Async 和 await 从字面意思上很好理解，async是异步的意思，await有等待的意思，而两者的用法也是如此，async用于声明一个function是异步的，而await用于等待一个异步方法完成</p>
<h2 id="37-有使用过vue吗？说说你对vue的理解"><a href="#37-有使用过vue吗？说说你对vue的理解" class="headerlink" title="37.有使用过vue吗？说说你对vue的理解"></a>37.有使用过vue吗？说说你对vue的理解</h2><p>(1)Vue是一个用于创建用户界面的开源的JavaScript框架，也是一个创建单页应用的web应用框架<br>(2)Vue的核心特性是 数据驱动（MVVM）<br>①MVVM 表示的是Model -View -ViewModel<br>1)Model :模型层，负责处理业务逻辑以及和服务器端进行交互<br>2)View 视图层，负责将数据模型转化为UI展示出来，还可以简单的理解为HTML页面<br>3)ViewModel 视图模型层，用来连接Model和View 是Model和View之间的通信桥梁<br>②组件化：<br>1)一句话来说就是把图形 非图形的各种逻辑均抽象成为一个统一的概念来实现开发的模式<br>2)组件化可以降低整个系统的耦合度，提高开发效率  便于调试 提高了代码的可维护性<br>③指令系统：<br>1)指令是带有V-前缀的特殊属性作用，当表达式的值改变时，将其产生的连带影响，响应式的作用于DOM<br>2)常用的指令有： V-if v-model  v-bind  v-on v-model<br>④Vue所有的界面事件 都只是去操作数据的，Jquery操作 Vue所有界面的改动，都是根据数据自动绑定出来的，Jquery操作DOM<br>⑤Vue和React的对比:<br>1)都有组件化思想，都支持服务器渲染 ，都有虚拟DOM  数据驱动视图，都支持native的方案，都有自己的构建工具<br>2)数据流向不同， react单向数据流， vue双向数据流，<br>3)数据变化的实现原理不同，React使用不可变数据，vue使用可变数据<br>4)组件化通信的不同 react中使用回调函数来进行通信， vue中子组件向父组件传递消息的方式有两种，事件和回调函数<br>5)Diff算法不同，react主要使用diff队列保存需要更新哪些DOM 得到patch树，在统一的操作批量更新DOM  Vue使用双向指针，边对比，边更新DOM</p>
<h2 id="38-你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"><a href="#38-你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢" class="headerlink" title="38.你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"></a>38.你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢</h2><p>(1)什么是SPA：<br>①Spa 翻译过来就是单页应用spa是一种网络程序或者网站的模型，她通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用之中，所有必要的代码都通过单个页面的加载而进行检索，或者根据需要 动态装载适当的资源并添加到页面，页面在任何时间点都不会重新加载，也不讲控制转移到其它页面<br>(2)优缺点：<br>①优点：<br>1)具有桌面应用的即时性，网站的可移植性和可访问性<br>2)用户体验好，快，内容的改变不需要重新加载整个页面<br>3)良好的前后端分离，分工更明确<br>②缺点：<br>1)不利于搜索引擎的抓取<br>2)首次渲染速度相对较慢<br>(3)实现一个spa<br>①原理<br>1)监听地址栏中hash变化驱动界面变化<br>2)用pushsate记录浏览器的历史，驱动界面发送变化<br>②实现：<br>1)Hash模式 核心通过监听url中的hash来进行路由跳转<br>history模式<br>history 模式核心借用 HTML5 history api，api 提供了丰富的 router 相关属性先了解一个几个相关的api</p>
<p>history.pushState 浏览器历史纪录添加记录<br>history.replaceState修改浏览器历史纪录中当前纪录<br>history.popState 当 history 发生变化时触发</p>
<h2 id="39-SPA首屏加载速度慢的怎么解决？"><a href="#39-SPA首屏加载速度慢的怎么解决？" class="headerlink" title="39.SPA首屏加载速度慢的怎么解决？"></a>39.SPA首屏加载速度慢的怎么解决？</h2><p>什么是首屏加载：<br>首屏时间 指的是浏览器从响应用户输入网址地址，到首屏呢容渲染完成的时间，此时整个网页不一定要全部渲染完成，但是需要展示当前视窗需要的内容 首屏加载可以说是用户体验中最重要的环节</p>
<p>加载慢的原因：<br>网络延时问题<br>资源文件体积是否过大<br>资源是否重复发送请求去加载了<br>加载脚本的时候，渲染内容堵塞了</p>
<p>解决方法：<br>减少入口文件体积<br>静态资源本地保存<br>UI框架按需加载<br>图片资源的压缩<br>组件重复打包<br>开启GZIP压缩<br>使用SSR</p>
<h2 id="40-VUE路由的原理"><a href="#40-VUE路由的原理" class="headerlink" title="40.VUE路由的原理"></a>40.VUE路由的原理</h2><p>实现一个静态Install方法，因为作为插件都必须有这个方法，给Vue.use去调用<br>可以监听路由变化<br>解析配置的路由，及解析router的配置项routes 能根据路由匹配到对应组件<br>实现两个全局组件的router-link  和router-view （最终落地点）</p>
<h2 id="41-Vue中组件和插件有什么区别？"><a href="#41-Vue中组件和插件有什么区别？" class="headerlink" title="41.Vue中组件和插件有什么区别？"></a>41.Vue中组件和插件有什么区别？</h2><p>组件：把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件、<br>优势：降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求；调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题；提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级<br>插件：常用来为 Vue 添加全局功能 功能范围：添加全局方法或者属性；添加全局资源；通过全局混入来添加一些组件选项；添加Vue实例方法，通过把它们添加到Vue.prototype上实现；一个库，提供自己的API，同时提供上面提到的一个或多个功能<br>区别：<br>编写形式：组件（编写一个组件，可以有很多方式，我们最常见的就是vue单文件的这种格式，每一个.vue文件我们都可以看成是一个组件 还可以通过template属性来编写一个组件，如果组件内容多，我们可以在外部定义template组件内容，如果组件内容并不多，我们可直接写在template属性上）插件（vue插件的实现应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象）<br>注册形式：组件（vue组件注册主要分为全局注册与局部注册 全局注册通过Vue.component方法，第一个参数为组件的名称，第二个参数为传入的配置项 局部注册只需在用到的地方通过components属性注册一个组件）</p>
<p>插件（插件的注册通过Vue.use()的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项 注册插件的时候，需要在调用 new Vue() 启动应用之前完成 Vue.use会自动阻止多次注册相同插件，只会注册一次）<br>使用场景：组件（用来构成你的 App 的业务模块，它的目标是 App.vue）插件（用来增强你的技术栈的功能模块，它的目标是 Vue 本身 用来增强你的技术栈的功能模块，它的目标是 Vue 本身）</p>
<h2 id="42-Vue组件之间的通信方式都有哪些"><a href="#42-Vue组件之间的通信方式都有哪些" class="headerlink" title="42.Vue组件之间的通信方式都有哪些"></a>42.Vue组件之间的通信方式都有哪些</h2><p>分类：父子组件间的通信、兄弟组件间的通信、祖孙与后代组件之间的通信、非关系组件间之间的通信<br>方式：<br>Props：适用于父组件传递数据给子组件 子组件设置props属性 定义接收父组件传递过来的参数 父组件在使用子组件标签中通过字面量来传递值<br>$emit触发自定义事件：适用于子组件传递数据给父组件 子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值 父组件绑定监听器获取到子组件传递过来的参数<br>Ref：父组件在使用子组件的时候设置ref 父组件通过设置子组件ref来获取数据（this.$ref.foo）<br>EventBus：适用于兄弟组件传值 创建一个中央事件总线EventBus 兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值 另一个兄弟组件通过$on监听自定义事件<br>$parent或$root：通过共同祖辈$parent或者$root搭建通信桥连接<br>$attr与$listeners：适用于祖先传递数据给子孙 设置批量向下传属性$attrs和$listeners 包含了父级作用域中不作为prop被识别且获取的特性绑定 可以通过v-bind&#x3D;”$attrs”传入内部组件<br>Procide与inject：在祖先组件定义provide属性 返回传递的值；在后代组件通过inject接收组件传递过来的值<br>Vuex：适用于复杂关系的组件数据传递</p>
<h2 id="43-你了解vue的diff算法吗？说说看"><a href="#43-你了解vue的diff算法吗？说说看" class="headerlink" title="43.你了解vue的diff算法吗？说说看"></a>43.你了解vue的diff算法吗？说说看</h2><p>diff 算法是一种通过同层的树节点进行比较的高效算法 它有两个特点：比较只会在同层级进行, 不会跨层级比较；在diff比较的过程中，循环从两边向中间比较<br>diff 算法在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较<br>diff整体策略为：深度优先，同层比较<br>原理：当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图</p>
<h2 id="44-为什么需要-Virtual-Dom"><a href="#44-为什么需要-Virtual-Dom" class="headerlink" title="44.为什么需要 Virtual Dom"></a>44.为什么需要 Virtual Dom</h2><p>Virtual Dom也就是虚拟Dom 实际上它只是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上<br>在Javascript对象中，虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的名命可能会有差别<br>创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应<br>需要：DOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的 真实的DOM节点，哪怕一个最简单的div也包含着很多属性 DOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的真实的DOM节点，哪怕一个最简单的div也包含着很多属性 操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验<br>虚拟dom比真实dom体积小,操作是相对来说消耗性能少,如果在页面中删除一个dom,会引起重绘,影响后边元素的布局 虚拟dom不会进行回流和重绘操作 虚拟dom进行频繁的修改,然后一次性比较并修改真实DOM中需要改的部分,最后并在真实DOM中进行回流和重绘,减少过多DOM节点的回流和重绘<br>虚拟dom可能跨端(在服务器端也可以使用vue技术),跨平台</p>
<h2 id="45-Vue3-0的设计目标是什么？做了哪些优化"><a href="#45-Vue3-0的设计目标是什么？做了哪些优化" class="headerlink" title="45.Vue3.0的设计目标是什么？做了哪些优化"></a>45.Vue3.0的设计目标是什么？做了哪些优化</h2><p>设计目标：更小（Vue3移除一些不常用的 API 引入tree-shaking，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了）、更快（diff算法优化；静态提升；事件监听缓存；SSR优化）、typescript支持、API设计一致性、提高自身可维护性、开放更多底层功能<br>优化：源码（源码管理：vue3整个源码是通过 monorepo的方式维护的，根据功能将不同的模块拆分到packages目录下面不同的子目录中 Vue3是基于typeScript编写的，提供了更好的类型检查，能支持复杂的类型推导）、性能（体积优化、编译优化、数据劫持优化（vue3通过proxy监听整个对象））、语法API（优化逻辑组织：相同功能的代码编写在一块，而不像options API那样，各个功能的代码混成一块、优化逻辑复用：通过composition这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可）</p>
<h2 id="46-Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#46-Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="46.Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>46.Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h2><p>OptionsApi 是什么？<br>Options API，即大家常说的选项API，即以vue为后缀的文件，通过定义methods，computed，watch，data等属性与方法，共同处理页面逻辑</p>
<p>CompositionAPI是什么？<br>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p>
<p>在逻辑组织和逻辑复用方面，Composition API是优于Options API<br>因为Composition API几乎是函数，会有更好的类型推断。<br>Composition API对 tree-shaking 友好，代码也更容易压缩<br>Composition API中见不到this的使用，减少了this指向不明的情况<br>如果是小型组件，可以继续使用Options API，也是十分友好的</p>
<h2 id="47-说一下Vue数据响应式的原理"><a href="#47-说一下Vue数据响应式的原理" class="headerlink" title="47.说一下Vue数据响应式的原理"></a>47.说一下Vue数据响应式的原理</h2><p>响应式”，是指当数据改变后，Vue 会通知到使用该数据的代码。例如，视图渲染中使用了数据，数据改变后，视图也会自动更新。简而言之就是数据变页面变</p>
<p>实现原理：Vue在组件和实例初始化的时候，会将data里的数据进行数据劫持(object.definepropty对数据做处理)。被解除过后的数据会有两个属性：一个叫getter，一个叫setter。</p>
<p>getter是使用数据的时候触发，setter是在修改数据的时候触发，修改数据的时候触发setter，同时也触发了底层的watcher监听，通知dom修改刷新</p>
<p>Vue中数据变页面一定变嘛？、</p>
<p>那么问题来了，数据变页面一定变么？<br>不一定，数据变页面变的原因是因为数据劫持了data</p>
<h2 id="48-说说对-React-的理解？有哪些特性？"><a href="#48-说说对-React-的理解？有哪些特性？" class="headerlink" title="48.说说对 React 的理解？有哪些特性？"></a>48.说说对 React 的理解？有哪些特性？</h2><p>React，用于构建用户界面的 JavaScript 库，只提供了 UI 层面的解决方案<br>遵循组件设计模式、声明式编程范式和函数式编程概念，以使前端应用程序更高效<br>使用虚拟 DOM 来有效地操作 DOM，遵循从高阶组件到低阶组件的单向数据流<br>帮助我们将界面成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，构成整体页面<br>react 类组件使用一个名为 render() 的方法或者函数组件return，接收输入的数据并返回需要展示的内容<br>React 特性有很多，如：<br>JSX 语法<br>单向数据绑定<br>虚拟 DOM<br>声明式编程<br>Component<br>React 存在的优势：<br>高效灵活<br>声明式的设计，简单使用<br>组件式开发，提高代码复用率<br>单向响应的数据流会比双向绑定的更安全，速度更快</p>
<h2 id="49-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？"><a href="#49-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？" class="headerlink" title="49.说说 Real DOM 和 Virtual DOM 的区别？优缺点？"></a>49.说说 Real DOM 和 Virtual DOM 的区别？优缺点？</h2><p>两者的区别如下：<br>虚拟 DOM 不会进行排版与重绘操作，而真实 DOM 会频繁重排与重绘<br>虚拟 DOM 的总损耗是“虚拟 DOM 增删改+真实 DOM 差异增删改+排版与重绘”，真实 DOM 的总损耗是“真实 DOM 完全增删改+排版与重绘”<br>真实 DOM 的优势：<br>易用<br>缺点：<br>效率低，解析速度慢，内存占用量过高<br>性能差：频繁操作真实 DOM，易于导致重绘与回流<br>使用虚拟 DOM 的优势如下：<br>简单方便：如果使用手动操作真实 DOM 来完成页面，繁琐又容易出错，在大规模应用下维护起来也很困难<br>性能方面：使用 Virtual DOM，能够有效避免真实 DOM 数频繁更新，减少多次引起重绘与回流，提高性能<br>跨平台：React 借助虚拟 DOM，带来了跨平台的能力，一套代码多端运行<br>缺点：<br>在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化<br>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，速度比正常稍慢</p>
<h2 id="50-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？"><a href="#50-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？" class="headerlink" title="50.说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？"></a>50.说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？</h2><p>Mounting(挂载阶段)：已插入真实 DOM<br>Updating(更新阶段)：正在被重新渲染<br>Unmounting(卸载阶段)：已移出真实 DOM</p>
<p>挂载阶段:</p>
<ul>
<li>constructor() 在 React 组件挂载之前，会调用它的构造函数。</li>
<li>componentWillMount: 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。</li>
<li>componentDidMount(): 在组件挂载后（插入 DOM 树中）立即调用</li>
</ul>
<p>更新运行阶段:</p>
<ul>
<li>componentWillReceiveProps: 在接受父组件改变后的props需要重新渲染组件时用到的比较多，外部组件传递频繁的时候会导致效率比较低</li>
<li>shouldComponentUpdate():用于控制组件重新渲染的生命周期，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新</li>
<li>render(): render() 方法是 class 组件中唯一必须实现的方法。</li>
<li>componentWillUpdate(): shouldComponentUpdate返回true以后，组件进入重新渲染完成之前进入这个函数。</li>
<li>componentDidUpdate(): 每次state改变并重新渲染页面后都会进入这个生命周期<br>卸载或销毁阶段<br>componentWillUnmount ()： 在此处完成组件的卸载和数据的销毁。</li>
</ul>
<h2 id="51-说说-React中的setState执行机制"><a href="#51-说说-React中的setState执行机制" class="headerlink" title="51.说说 React中的setState执行机制"></a>51.说说 React中的setState执行机制</h2><p>React并不像vue2中调用Object.defineProperty数据响应式或者Vue3调用Proxy监听数据的变化</p>
<p>必须通过setState方法来告知react组件state已经发生了改变</p>
<p>通过触发事件，执行<code>this.setState</code>方法更新<code>state</code>状态，然后重新执行<code>render</code>函数，从而导致页面的视图更新</p>
<p>如果直接修改<code>state</code>的状态</p>
<p>使用setState更新数据的时候，setState的更新类型分成：</p>
<p>异步更新<br>同步更新</p>
<p>异步:<br>在使用setstate更新数据的时候，并不能在执行完setState之后立马拿到最新的state的结果</p>
<p>如果想要立刻获取更新后的值，在第二个参数的回调中更新后会执行</p>
<p>在组件生命周期或React合成事件中，setState是异步<br>在setTimeout或者原生dom事件中，setState是同步</p>
<p>在批量更新的时候  对同一个值进行多次 setState， setState 的批量更新策略会对其进行覆盖，取最后一次的执行结果<br>如果是下一个state依赖前一个state的话，推荐给setState一个参数传入一个function<br>而在setTimeout或者原生dom事件中，由于是同步的操作，所以并不会进行覆盖现象</p>
<h2 id="52-说说对React中类组件和函数组件的理解？有什么区别？"><a href="#52-说说对React中类组件和函数组件的理解？有什么区别？" class="headerlink" title="52.说说对React中类组件和函数组件的理解？有什么区别？"></a>52.说说对React中类组件和函数组件的理解？有什么区别？</h2><p>class组件是有状态的组件，可以定义state状态，函数组件无状态<br>class组件有生命周期的，函数组件无生命周期<br>class组件是由this对象，函数组件没有this对象<br>组件调用： class组件实例化后调用render方法调用，函数组件直接调用的。<br>class组件内部的话，render方法return返回渲染jsx模板，函数组件直接返回即可<br>ref获取子组件的对象，class组件可以直接获取到的，函数组件无法直接获取到。<br>绑定bind改变this指向，只适用于class组件</p>
<h2 id="53-说说对React-Hooks的理解？解决了什么问题？"><a href="#53-说说对React-Hooks的理解？解决了什么问题？" class="headerlink" title="53.说说对React Hooks的理解？解决了什么问题？"></a>53.说说对React Hooks的理解？解决了什么问题？</h2><p>useState</p>
<p>useState()用于为函数组件引入状态。在useState()中，数组第一项为一个变量，指向状态的当前值。类似this.state,第二项是一个函数，用来更新状态,类似setState</p>
<p>useEffect</p>
<p>useEffect()接受两个参数，第一个参数是你要进行的异步操作，第二个参数是一个数组，用来给出Effect的依赖项。只要这个数组发生变化，useEffect()就会执行</p>
<p>useRef</p>
<p>相当于class组件中的createRef的作用，ref.current获取绑定的对象</p>
<p>useContext</p>
<p>接受context状态树传递的数据内容</p>
<p>useReducer</p>
<p>接受reducer函数和状态的初始值作为参数，返回一个数组，其中第一项为当前的状态值，第二项为发送action的dispatch函数</p>
<p>userMemo useCallback</p>
<p>useMemo 和 useCallback接收的参数都是一样,第一个参数为回调，第二个参数为要依赖的数据<br>共同作用：仅仅依赖数据发生变化, 才会调用，也就是起到缓存的作用。useCallback缓存函数，useMemo 缓存返回值。</p>
<h2 id="54-说说你对Redux的理解？其工作原理？"><a href="#54-说说你对Redux的理解？其工作原理？" class="headerlink" title="54.说说你对Redux的理解？其工作原理？"></a>54.说说你对Redux的理解？其工作原理？</h2><p>在react中每个组件的state是由自身进行管理，包括组件定义自身的state、组件之间的通信通过props传递、使用Context实现数据共享等，如果让每个组件都存储自身相关的状态，理论上来讲不会影响应用的运行，但在开发及后期我们将比较难以维护，所以我们可以把数据进行集中式的管理，redux就是一个实现上述集中管理的容器的工具，redux并不是只应用在react中，还与其他界面库一起使用，如Vue</p>
<p>三大原则<br>state数据必须是单一数据源<br>redux中的state数据必须 是只读的，只能通过dispatch调用actions修改<br>Reducer必须使用纯函数来执行修改</p>
<p>React的组件需要获取或者修改页面的数据，通过dispatch方法调用actions进入到Reducer函数中修改state的数据内容，state更新后，通知组件更新页面即可。</p>
<p>redux的使用步骤<br>创建一个store文件夹，新建一个index.js文件<br>文件中导入redux的createStore方法，用于创建公共数据区域<br>创建一个reducer纯函数，接受两个参数state，actions分别表示分别表示数据和操作state的方法，返回state数据给组件页面<br>把reducer作为createStore的参数抛出<br>在需要使用的页面导入store文件，通过store.getState获取数据，通过store.dispatch触发action修改state数据<br>store.subscrible 方法监听 store 的改变，避免数据不更新</p>
<h2 id="55-说说-React-性能优化的手段有哪些"><a href="#55-说说-React-性能优化的手段有哪些" class="headerlink" title="55.说说 React 性能优化的手段有哪些"></a>55.说说 React 性能优化的手段有哪些</h2><p>1、前端通用优化。这类优化在所有前端框架中都存在，重点就在于如何将这些技巧应用在React组件中。<br>懒加载，在SPA中，懒加载优化一般用于从一个路由跳转到另一个路由。还可用于用户操作后才展示的复杂组件，比如点击按钮后展示的弹窗模块。<br>按优先级更新，及时响应用户，其思想是优先响应用户行为，在完成耗时操作。<br>缓存优化，缓存优化往往是最简单有效的优化方式，在React组件中常用到useMemo缓存上次计算的结果。当useMemo的依赖未发生变化时，就不会触发重新计算。<br>2、减少不必要的组件更新，这类优化是在组件状态发生变更后，通过减少不必要的组件更新来实现，对应到React中就是：减少渲染的节点、降低组件渲染的复杂度、充分利用缓存避免重新渲染。<br>如果是类组件，可以使用shouldComponentUpdate生命周期函数，可以在重新渲染组件时触发，可以利用此事件来决定何时重新渲染组件。<br>不要使用内联函数定义，会导致每次调用render函数时都会创建一个新的函数实例。<br>不要再render方法中导出数据。<br>在函数组件中使用useCallback和useMemo来进行组件优化，依赖没有变化的话，不重复执行。</p>
<h2 id="56-vue、react、angular-区别"><a href="#56-vue、react、angular-区别" class="headerlink" title="56.vue、react、angular 区别"></a>56.vue、react、angular 区别</h2><ol>
<li>基本概念</li>
</ol>
<p>Angular 是一个应用设计框架与开发平台，用于创建高效、复杂、精致的单页面应用。</p>
<p>React 是一个用于构建用户界面的 JavaScript 库</p>
<p>Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。<br>2. 三者比较<br>2.1 相同点</p>
<ol>
<li><p>都是基于javascript&#x2F;typescript的前端开发库，为前端开发提供高效、复用性高的开发方式</p>
</li>
<li><p>都有组件和模板的开发思想</p>
</li>
<li><p>各自的组件都有生命周期，不用的组件可以卸载，不占用资源</p>
</li>
<li><p>都支持指令，如样式、事件等的指令<br>2.2 不同点</p>
</li>
<li><p>创始和发行不同：</p>
<pre><code>Angular是由googl提供支持的，初始发行于 2016年9月；React由Facebook维护，初始发行于 2013年3月；Vue是由前google人员创建，初始发行于2014年2月
</code></pre>
</li>
<li><p>应用类型不同：</p>
<pre><code>Angular支持开发native应用程序、SPA单页应用程序、混合应用程序和web应用程序；React支持开发SPA和移动应用程序；Vue支持开发高级SPA，开始支持native应用程序
</code></pre>
</li>
<li><p>模型不同</p>
<pre><code>angular基于MVC（模型-视图-控制器）架构；react和vue是基于Virtual DOM（虚拟的文档对象模型）
</code></pre>
</li>
<li><p>数据流流向不同</p>
<p>  Angular使用的是双向数据绑定，React用的是单数据流的，而Vue则支持两者。</p>
</li>
<li><p>对微应用和微服务的支持不同</p>
<pre><code> Angular使用的是TypeScript，因此它更适合于单页Web应用（single page web application，SPA），而非微服务。相反，React和Vue的灵活性更适合微应用和微服务的开发。
</code></pre>
</li>
<li><p>对原生应用的支持不同</p>
<pre><code> React Native为iOS和Android开发原生应用；Angular的NativeScript已被原生应用所采用，特别是Ionic框架已经被广泛地运用在制作混合应用等方面；Vue的Weex平台正在开发之中，尚无下一步使之成为全面跨平台的计划。
</code></pre>
</li>
<li><p>框架和库</p>
<pre><code> Angular 是一个框架而不是一个库，因为它提供了关于如何构建应用程序的强有力的约束，并且还提供了更多开箱即用的功能。React 和 Vue 是是一种库，可以和各种包搭配。
</code></pre>
</li>
<li><p>组件之间传值方式不同</p>
<p> Angular 中直接的父子组件，父组件可以直接访问子组件的 public 属性和方法，也可以借助于@Input 和 @Output 进行通讯。没有直接关系的，借助于 Service 单例进行通讯；React 组件之间通过通过prop或者state来通信，不同组件之间还有Rex状态管理功能；Vue组件之间通信通过props ，以及Vuex状态管理来传值</p>
</li>
</ol>
<h2 id="57-说说你对-TypeScript-的理解？与-JavaScript-的区别"><a href="#57-说说你对-TypeScript-的理解？与-JavaScript-的区别" class="headerlink" title="57.说说你对 TypeScript 的理解？与 JavaScript 的区别"></a>57.说说你对 TypeScript 的理解？与 JavaScript 的区别</h2><p>TypeScript 是 Microsoft 开发和维护的一种面向对象的编程语言。它是 JavaScript 的超集，包含了 JavaScript 的所有元素，可以载入 JavaScript 代码运行，并扩展了 JavaScript 的语法。<br>TypeScript 具有以下特点：</p>
<pre><code>TypeScript 增加了静态类型、类、模块、接口和类型注解

TypeScript 可用于开发大型的应用
</code></pre>
<p>JavaScript 和 TypeScript 的主要差异</p>
<pre><code>TypeScript 从核心语言方面和类概念的模塑方面对 JavaScript 对象模型进行扩展。

JavaScript 代码可以在无需任何修改的情况下与 TypeScript 一同工作，同时可以使用编译器将 TypeScript 代码转换为 JavaScript。

TypeScript 通过类型注解提供编译时的静态类型检查。

TypeScript 中的数据要求带有明确的类型，JavaScript不要求。

TypeScript 为函数提供了缺省参数值。

TypeScript 引入了 JavaScript 中没有的“类”概念。

TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。
</code></pre>
<h2 id="58-说说你对-TypeScript-中泛型的理解？应用场景？"><a href="#58-说说你对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="58.说说你对 TypeScript 中泛型的理解？应用场景？"></a>58.说说你对 TypeScript 中泛型的理解？应用场景？</h2><p>泛型程序设计（generic programming）是程序设计语言的一种风格或范式</p>
<p>泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型 在typescript中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性<br>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。<br>在编写 typescript 的时候，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性的时候，这种情况下就可以使用泛型</p>
<h2 id="59-说说你对微信小程序的理解？优缺点？"><a href="#59-说说你对微信小程序的理解？优缺点？" class="headerlink" title="59.说说你对微信小程序的理解？优缺点？"></a>59.说说你对微信小程序的理解？优缺点？</h2><p>小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用</p>
<p>也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载<br>优点：<br>1、对用户使用上来说，确实方便，要用的时候打开，不用的时候关掉，即用即走。这点比需要下载，还要占用手机内存空间的APP要好。<br>2、主要的样式代码都封装在微信小程序里面，所以打开速度比普通的H5要快，接近原生APP。<br>3、可以调用比H5更多的手机系统功能来进行开发，例如GPS定位、录音、拍视频、重力感应等，能开发更丰富的使用场景。<br>4、在安卓手机上可以添加到手机桌面，看上去跟原生APP差不多，但仅限安卓手机，iphone就不行了。<br>5、运行速度跟APP差不多，也能做出很多H5不做到的功能，开发成本跟H5差不多，相对来说开发成本比APP要低。<br>缺点：<br>1、微信小程序只有1M的大小，这样导致无法开发大型一些的小程序。所以目前你会看到很多小程序真的很小很简单。<br>2、小程序的技术框架还不稳定，开发方法时常有修改，导致短时间内经常要升级维护。<br>3、不能跳转外链网址，所以间接影响了小程序的开放性。<br>4、不能直接分享到朋友圈，哎呀，少了一个重要的推广方式。<br>5、需要像APP一样审核上架，这点比HTML5即做即发布要麻烦些。</p>
<h2 id="60-说说你对发布订阅、观察者模式的理解？区别？"><a href="#60-说说你对发布订阅、观察者模式的理解？区别？" class="headerlink" title="60.说说你对发布订阅、观察者模式的理解？区别？"></a>60.说说你对发布订阅、观察者模式的理解？区别？</h2><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新</p>
<p>观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯</p>
<p>发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在</p>
<p>同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在</p>
<p>区别：<br>在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</p>
<p>在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。</p>
<p>观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）</p>
<h2 id="61-项目做过哪些性能优化"><a href="#61-项目做过哪些性能优化" class="headerlink" title="61.项目做过哪些性能优化"></a>61.项目做过哪些性能优化</h2><p>1、尽量减少http请求<br>2、压缩源码和静态资源<br>3、使用外部JavaScript和CSS<br>4、图片懒加载<br>5、源码优化<br>(1)代码模块化 将重复的代码封装成组件，以得到复用的效果<br>(2)写循环语句时设置key值，可以快速定位到该节点，提升性能<br>6、减少DOM操作：大量的DOM操作会导致游览器重复的渲染<br>7、首屏渲染优化<br>8、合理使用游览器缓存</p>
<h2 id="62-描述浏览器的渲染过程，DOM树和渲染树的区别"><a href="#62-描述浏览器的渲染过程，DOM树和渲染树的区别" class="headerlink" title="62.描述浏览器的渲染过程，DOM树和渲染树的区别"></a>62.描述浏览器的渲染过程，DOM树和渲染树的区别</h2><p>浏览器的渲染过程：</p>
<p>解析HTML构建 DOM(DOM树)，并行请求 css&#x2F;image&#x2F;js<br>CSS 文件下载完成，开始构建 CSSOM(CSS树)<br>CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)<br>布局(Layout)：计算出每个节点在屏幕中的位置<br>显示(Painting)：通过显卡把页面画到屏幕上<br>DOM树 和 渲染树 的区别：</p>
<p>DOM树与HTML标签一一对应，包括head和隐藏元素<br>渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性</p>
<h2 id="63-你认为什么样的前端代码是好的"><a href="#63-你认为什么样的前端代码是好的" class="headerlink" title="63.你认为什么样的前端代码是好的"></a>63.你认为什么样的前端代码是好的</h2><p>高复用低耦合，这样文件小，好维护，而且好扩展。<br>具有可用性、健壮性、可靠性、宽容性等特点<br>遵循设计模式的六大原则</p>
<h2 id="64-从浏览器地址栏输入url到显示页面的步骤"><a href="#64-从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="64.从浏览器地址栏输入url到显示页面的步骤"></a>64.从浏览器地址栏输入url到显示页面的步骤</h2><p>1、浏览器的地址栏输入URL并按下回车。</p>
<p>2、浏览器查找当前URL的DNS缓存记录。</p>
<p>3、DNS解析URL对应的IP。</p>
<p>4、根据IP建立TCP连接（三次握手）。</p>
<p>5、HTTP发起请求。</p>
<p>6、服务器处理请求，浏览器接收HTTP响应。</p>
<p>7、渲染页面，构建DOM树。</p>
<p>8、关闭TCP连接（四次挥手）。</p>
<h2 id="65-http-请求报文响应报文的格式"><a href="#65-http-请求报文响应报文的格式" class="headerlink" title="65.http 请求报文响应报文的格式"></a>65.http 请求报文响应报文的格式</h2><p>HTTP请求报文主要由请求行、请求头、空行、请求正文<br>请求行：请求行是由请求方法字段、URL字段、和HTTP协议版本字段三部分组成，它们用空格分隔。比如GET &#x2F;data&#x2F;info.html HTTP&#x2F;1.1，方法字段就是HTTP使用的请求方法。<br>请求头: 在请求头中存在cookie、客户端的主机名和端口等信息<br>空行：它的作用是通过一个空行，告诉服务器请求头部到此为止<br>请求体：可选部分，比如GET请求就没有请求正文<br>HTTP响应报文主要由状态行、响应头部、响应正文<br>状态行：状态行格式分别为协议版本、状态码、状态码描述，之间由空格分隔。其中状态码由三位数字组成，第一个数字定义了响应的类别，且有物种可能取值<br>1XX：指示信息–表示请求已接受，继续处理<br>2XX：成功–表示请求已被成功接收、理解<br>3XX：重定向<br>4XX：客户端错误<br>5XX：服务端错误<br>响应头部：与请求头部类似，为响应报文添加了一些附加信息，常见的有Server服务器的应用程序的名称和版本，Content-Type响应正文的类型等。<br>响应正文：服务器返回给服务端的响应数据</p>
<h2 id="66-Token-cookie-session-区别"><a href="#66-Token-cookie-session-区别" class="headerlink" title="66.Token cookie session 区别"></a>66.Token cookie session 区别</h2><p>Cookie由服务端生成，发送给浏览器，游览器把cookie以键值对的形式存储到本地，每次请求时网站会自动把cookie发送给服务端，每个cookie存储空间为3-4Kb，不会占据大量内存，但是每个站点的cookie数量是有限的。<br>Session 由服务端存储，是基于cookie实现的，session本身存储在服务端，但服务端会将sessionID发送给浏览器保存到cookie中，每次请求时会携带上sessionID去服务端。<br>Token是服务器经过计算生成的一串加密字符串，作为客户端进行请求的令牌，当第一次登陆时，服务器会生成一个token并返回给客户端，当客户端发起请求时携带上Token到服务端，如果验证成功就向客户端返回请求的数据。</p>
<h2 id="67-CORS跨域的原理"><a href="#67-CORS跨域的原理" class="headerlink" title="67.CORS跨域的原理"></a>67.CORS跨域的原理</h2><p>CORS是跨域资源共享，它是W3C标准，属于跨域AJAX请求的根本解决方法。<br>CORS跨域原理就是，只需要服务器端设置Access-Control-Allow-Origin。<br>服务器端对于CORS的支持，主要是通过设置Access-Control-Allow-Origin来进行的。如果游览器检测到相应的设置，就可以允许AJAX进行跨域的访问。</p>
<h2 id="68-什么是MVVM"><a href="#68-什么是MVVM" class="headerlink" title="68.什么是MVVM"></a>68.什么是MVVM</h2><p>MVVM是Model-View-ViewModel的简写，即模型层-视图层-视图模型<br>模型指的是后端传递的数据<br>视图指的是所看到的页面<br>视图模型是MVVM模式的核心，它是连接view和model的桥梁<br>MVVM采用的是双向数据绑定，view中数据变化将反映到model上，反之，model中数据变化也会自动展示在页面上，ViewModel负责把Model的数据同步到View中显示出来，也负责把View的修改同步会Model。<br>MVVM的核心思想，是关注model的变化，让MVVM框架利用自己的机制自动更新DOM，也就是所谓的数据-视图分离，数据不会影响视图。</p>
<h2 id="69-说说你对版本管理的理解？常用的版本管理工具有哪些？"><a href="#69-说说你对版本管理的理解？常用的版本管理工具有哪些？" class="headerlink" title="69.说说你对版本管理的理解？常用的版本管理工具有哪些？"></a>69.说说你对版本管理的理解？常用的版本管理工具有哪些？</h2><p>版本控制就是一种软件工程技巧，借此能在开发的过程中，确保由不同人所编辑的同一程序文件都得到同步。通过版本控制，能记录任何工程项目内各个模块的改动历程，并为每次改动编上序号，版本控制能通过这些序号将程序恢复到之前的任意一状态，简言之，你的修改只要提交到版本控制系统，基本都能找回，版本控制系统就像一台时光机器，可以让你回到任何一个时间点。<br>版本管理根据类别可以分为三类<br>1、本地版本控制系统<br>此系统较为简单，很多系统中都有内置，适合管理文本。但是不支持远程操作，因此不适合多人版本开发<br>2、集中式版本控制系统<br>适合多人团队协作开发，代码集中化管理，但是必须联网，无法单机工作<br>3、分布式版本控制系统<br>适合多人团队协作开发、代码集中化管理、可以离线工作、每一个计算机都是一个完整仓库<br>常用的版本管理工具有CVS、Git、SVN、HG</p>
<h2 id="70-说说你对Git的理解？"><a href="#70-说说你对Git的理解？" class="headerlink" title="70.说说你对Git的理解？"></a>70.说说你对Git的理解？</h2><p>Git是一个分布式版本控制软件，最初目的是为了更好地管理Linux内核开发而设计的。<br>分布式版本控制系统的客户端不只是提取最新版本的文件快照，而是把代码仓库完整的克隆下来。这么一来，如果任何一处协同工作的服务器发生故障，那么都可以用任何一个克隆出来的本地仓库恢复。<br>项目开始，只有一个原始版仓库，别的机器可以clone这个原始版本库，那么所有clone的机器，它们的版本库其实都是一样的，并没有主次之分。</p>
<p>所以在实现团队协作的时候，只要有一台电脑充当服务器的角色，其他每个人都从这个“服务器”仓库clone一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<h2 id="71-说说Git常用的命令有哪些"><a href="#71-说说Git常用的命令有哪些" class="headerlink" title="71.说说Git常用的命令有哪些"></a>71.说说Git常用的命令有哪些</h2><p>Git config 配置用户信息<br>Git init 初始化仓库<br>Git clone url 克隆代码<br>Git add . 提交全部文件到缓存区<br>Git diff 查看当前代码add后，会add哪些内容<br>Git status 查看当前分支状态<br>Git pull <state> 拉取远程仓库的分支与本地当前分支合并<br>Git commit -m “注释信息” 提交代码到本地仓库<br>Git merge &lt;分支名&gt; 合并分支<br>Git fetch 获取线上最新版信息记录，不合并<br>Git remote -v 显示所有远程仓库<br>Git push 上传本地仓库代码到远程仓库</p>
<h2 id="72-说说-git-发生冲突的场景？如何解决？"><a href="#72-说说-git-发生冲突的场景？如何解决？" class="headerlink" title="72.说说 git 发生冲突的场景？如何解决？"></a>72.说说 git 发生冲突的场景？如何解决？</h2><p>发生冲突的场景<br>多个分支代码合并到一个分支时<br>多个分支向同一个远程仓库分支推送<br>具体情况就是，多个分支修改了同一个文件或者多个分支修改了同一个文件的名称。<br>当本地修改的文件和目标远程仓库的同一个文件都有修改，这时，无论是pull&#x2F;push&#x2F;merge时都会发生冲突。<br>解决方法：<br>修改文件之前先git pull 获取远程最新的代码，同步完之后在对代码进行修改。</p>
<h2 id="73-前端工程化的特点"><a href="#73-前端工程化的特点" class="headerlink" title="73.前端工程化的特点"></a>73.前端工程化的特点</h2><p>前端工程化可以分成四个方面来说，分别为模块化、组件化、规范化和自动化。</p>
<p>模块化<br>模块化是指将一个文件拆分成多个相互依赖的文件，最后进行统一的打包和加载，这样能够很好的保证高效的多人协作。其中包含</p>
<p>JS 模块化：CommonJS、AMD、CMD 以及 ES6 Module。<br>CSS 模块化：Sass、Less、Stylus、BEM、CSS Modules 等。其中预处理器和 BEM 都会有的一个问题就是样式覆盖。而 CSS Modules 则是通过 JS 来管理依赖，最大化的结合了 JS 模块化和 CSS 生态，比如 Vue 中的 style scoped。<br>资源模块化：任何资源都能以模块的形式进行加载，目前大部分项目中的文件、CSS、图片等都能直接通过 JS 做统一的依赖关系处理。<br>组件化<br>不同于模块化，模块化是对文件、对代码和资源拆分，而组件化则是对 UI 层面的拆分。</p>
<p>通常，我们会需要对页面进行拆分，将其拆分成一个一个的零件，然后分别去实现这一个个零件，最后再进行组装。 在我们的实际业务开发中，对于组件的拆分我们需要做不同程度的考量，其中主要包括细粒度和通用性这两块的考虑。 对于业务组件，你更多需要考量的是针对你负责业务线的一个适用度，即你设计的业务组件是否成为你当前业务的 “通用” 组件。</p>
<p>规范化<br>正所谓无规矩不成方圆，一些好的规范则能很好的帮助我们对项目进行良好的开发管理。规范化指的是我们在工程开发初期以及开发期间制定的系列规范，其中又包含了</p>
<p>项目目录结构<br>编码规范：对于编码这块的约束，一般我们都会采用一些强制措施，比如 ESLint、StyleLint 等。<br>联调规范<br>文件命名规范<br>样式管理规范：目前流行的样式管理有 BEM、Sass、Less、Stylus、CSS Modules 等方式。<br>git flow 工作流：其中包含分支命名规范、代码合并规范等。<br>定期 code review … 等等<br>自动化<br>从最早先的 grunt、gulp 等，再到目前的 webpack、parcel。这些自动化工具在自动化合并、构建、打包都能为我们节省很多工作。而这些只是前端自动化其中的一部分，前端自动化还包含了持续集成、自动化测试等方方面面。</p>
<p>以上就是我所了解的前端工程化，以工程的角度去理解我们的web前端。工程是工程，而不是某项技术。</p>
<h2 id="74为什么-GUI-渲染线程为什么与JS-引擎线程互斥"><a href="#74为什么-GUI-渲染线程为什么与JS-引擎线程互斥" class="headerlink" title="74为什么 GUI 渲染线程为什么与JS 引擎线程互斥"></a>74为什么 GUI 渲染线程为什么与JS 引擎线程互斥</h2><p>这是由于 S 是可以操作 DOM 的，如果同时修改元素属性并同时染界面(即 S线程和 UI线程同时运行)<br>。那么渲沈线程前后获得的元素就可能不一致了<br>。因此，为了防止渲染出现不可预期的结果，浏览器设定 GUI渲染线程和]S引擎线程为互斥关系<br>。Is引擎线程执行完后&#x3D;》GUI 染页面操作<br>当IS引擎线程执行时 GUI渲染线程会被挂起，GUI更新则会被保存在一个队列中等待S引擎线程空闲时立即被执行</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">YaYa</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/11/16/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">http://example.com/2022/11/16/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/head.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/16/vue3-antd-admin%E5%90%AF%E5%8A%A8%E9%94%99%E8%AF%AF/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">vue3-antd-admin启动错误</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">深拷贝浅拷贝</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">YaYa</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/isyayaya"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">is yaya Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">1.说说你对盒子模型的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2.css选择器有哪些？优先级？哪些属性可以继承？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%85%83%E7%B4%A0%E4%B8%8D%E5%AE%9A%E5%AE%BD%E9%AB%98%E5%91%A2%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3.元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%9B%9E%E6%B5%81%E8%B7%9F%E9%87%8D%E7%BB%98%EF%BC%9F%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BC%9A%E8%A7%A6%E5%8F%91%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4.怎么理解回流跟重绘？什么场景下会触发？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9F%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%81%9A%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">5.什么是响应式设计？响应式设计的基本原理是什么？如何做？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A6%82%E6%9E%9C%E8%A6%81%E5%81%9A%E4%BC%98%E5%8C%96%EF%BC%8CCSS%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">6.如果要做优化，CSS提高性能的方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AF%B9%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%99%E4%B8%AA%E8%81%8C%E4%BD%8D%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%90%86%E8%A7%A3%E7%9A%84%EF%BC%9F%E5%AE%83%E7%9A%84%E5%89%8D%E6%99%AF%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-number">7.</span> <span class="toc-text">7.对前端工程师这个职位是怎么样理解的？它的前景会怎么样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%AF%B4%E8%AF%B4JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AD%98%E5%82%A8%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">8.说说JavaScript中的数据类型？存储上的差别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-typeof-%E4%B8%8E-instanceof-%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">9.typeof 与 instanceof 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.</span> <span class="toc-text">10.说说你对闭包的理解？闭包使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-bind%E3%80%81call%E3%80%81apply-%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAbind"><span class="toc-number">11.</span> <span class="toc-text">11.bind、call、apply 区别？如何实现一个bind?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">12.</span> <span class="toc-text">12.说说你对事件循环的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-DOM%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">13.</span> <span class="toc-text">13.DOM常见的操作有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9BOM%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%B8%B8%E8%A7%81%E7%9A%84BOM%E5%AF%B9%E8%B1%A1%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">14.说说你对BOM的理解，常见的BOM对象你了解哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">15.Javascript本地存储的方式有哪些？区别及应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">16.什么是防抖和节流？有什么区别？如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87JS%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-number">17.</span> <span class="toc-text">17.如何通过JS判断一个数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">18.</span> <span class="toc-text">18.说说你对作用域链的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-JavaScript%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">19.JavaScript原型，原型链 ? 有什么特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-number">20.</span> <span class="toc-text">20.请解释什么是事件代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E8%B0%88%E8%B0%88This%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">21.</span> <span class="toc-text">21.谈谈This对象的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">22.</span> <span class="toc-text">22.new操作符具体干了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-null%EF%BC%8Cundefined-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">23.</span> <span class="toc-text">23.null，undefined 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-javascript-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E2%80%9Duse-strict%E2%80%9D-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">24.</span> <span class="toc-text">24.javascript 代码中的”use strict”;是什么意思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">25.</span> <span class="toc-text">25.同步和异步的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E8%B0%88%E4%B8%80%E8%B0%88%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">26.</span> <span class="toc-text">26.谈一谈箭头函数与普通函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-JS-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83%E3%80%81"><span class="toc-number">27.</span> <span class="toc-text">27.JS 数组和对象的遍历方式，以及几种方式的比较、</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">28.</span> <span class="toc-text">28.如何解决跨域问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-XML%E5%92%8CJSON%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">29.</span> <span class="toc-text">29.XML和JSON的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9webpack%E7%9A%84%E7%9C%8B%E6%B3%95"><span class="toc-number">30.</span> <span class="toc-text">30.谈谈你对webpack的看法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-webpack%E7%9A%84%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86"><span class="toc-number">31.</span> <span class="toc-text">31.webpack的打包原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96webpack%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6"><span class="toc-number">32.</span> <span class="toc-text">32.如何优化webpack打包速度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E8%AF%B4%E8%AF%B4webpack%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Loader%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">33.说说webpack中常见的Loader？解决了什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E8%AF%B4%E8%AF%B4webpack%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Plugin%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">34.说说webpack中常见的Plugin？解决了什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9promise%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">35.</span> <span class="toc-text">35.说说你对promise的了解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">35.0.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-number">35.0.2.</span> <span class="toc-text">状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">35.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">35.0.4.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">35.0.5.</span> <span class="toc-text">实例方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-number">35.0.6.</span> <span class="toc-text">构造函数方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">35.0.7.</span> <span class="toc-text">使用场景：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-async%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">36.</span> <span class="toc-text">36.async函数是什么，有什么作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87vue%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">37.</span> <span class="toc-text">37.有使用过vue吗？说说你对vue的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E4%BD%A0%E5%AF%B9SPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0SPA%E5%BA%94%E7%94%A8%E5%91%A2"><span class="toc-number">38.</span> <span class="toc-text">38.你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-SPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">39.SPA首屏加载速度慢的怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-VUE%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">40.</span> <span class="toc-text">40.VUE路由的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-Vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">41.Vue中组件和插件有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">42.</span> <span class="toc-text">42.Vue组件之间的通信方式都有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E4%BD%A0%E4%BA%86%E8%A7%A3vue%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4%E7%9C%8B"><span class="toc-number">43.</span> <span class="toc-text">43.你了解vue的diff算法吗？说说看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Virtual-Dom"><span class="toc-number">44.</span> <span class="toc-text">44.为什么需要 Virtual Dom</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-Vue3-0%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96"><span class="toc-number">45.</span> <span class="toc-text">45.Vue3.0的设计目标是什么？做了哪些优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-Vue3-0-%E6%89%80%E9%87%87%E7%94%A8%E7%9A%84-Composition-Api-%E4%B8%8E-Vue2-x-%E4%BD%BF%E7%94%A8%E7%9A%84-Options-Api-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">46.</span> <span class="toc-text">46.Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E8%AF%B4%E4%B8%80%E4%B8%8BVue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">47.</span> <span class="toc-text">47.说一下Vue数据响应式的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E8%AF%B4%E8%AF%B4%E5%AF%B9-React-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">48.</span> <span class="toc-text">48.说说对 React 的理解？有哪些特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E8%AF%B4%E8%AF%B4-Real-DOM-%E5%92%8C-Virtual-DOM-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">49.说说 Real DOM 和 Virtual DOM 的区别？优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-%E8%AF%B4%E8%AF%B4-React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%EF%BC%9F%E6%AF%8F%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">50.说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E8%AF%B4%E8%AF%B4-React%E4%B8%AD%E7%9A%84setState%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">51.</span> <span class="toc-text">51.说说 React中的setState执行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E8%AF%B4%E8%AF%B4%E5%AF%B9React%E4%B8%AD%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">52.</span> <span class="toc-text">52.说说对React中类组件和函数组件的理解？有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E8%AF%B4%E8%AF%B4%E5%AF%B9React-Hooks%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">53.</span> <span class="toc-text">53.说说对React Hooks的理解？解决了什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Redux%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">54.</span> <span class="toc-text">54.说说你对Redux的理解？其工作原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E8%AF%B4%E8%AF%B4-React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">55.</span> <span class="toc-text">55.说说 React 性能优化的手段有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-vue%E3%80%81react%E3%80%81angular-%E5%8C%BA%E5%88%AB"><span class="toc-number">56.</span> <span class="toc-text">56.vue、react、angular 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-TypeScript-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E4%B8%8E-JavaScript-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">57.</span> <span class="toc-text">57.说说你对 TypeScript 的理解？与 JavaScript 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-TypeScript-%E4%B8%AD%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">58.</span> <span class="toc-text">58.说说你对 TypeScript 中泛型的理解？应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">59.说说你对微信小程序的理解？优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">60.</span> <span class="toc-text">60.说说你对发布订阅、观察者模式的理解？区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E9%A1%B9%E7%9B%AE%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">61.</span> <span class="toc-text">61.项目做过哪些性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E6%8F%8F%E8%BF%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%EF%BC%8CDOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">62.</span> <span class="toc-text">62.描述浏览器的渲染过程，DOM树和渲染树的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E4%BD%A0%E8%AE%A4%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%98%AF%E5%A5%BD%E7%9A%84"><span class="toc-number">63.</span> <span class="toc-text">63.你认为什么样的前端代码是好的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">64.</span> <span class="toc-text">64.从浏览器地址栏输入url到显示页面的步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-http-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">65.</span> <span class="toc-text">65.http 请求报文响应报文的格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-Token-cookie-session-%E5%8C%BA%E5%88%AB"><span class="toc-number">66.</span> <span class="toc-text">66.Token cookie session 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-CORS%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">67.</span> <span class="toc-text">67.CORS跨域的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-%E4%BB%80%E4%B9%88%E6%98%AFMVVM"><span class="toc-number">68.</span> <span class="toc-text">68.什么是MVVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%B8%B8%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">69.</span> <span class="toc-text">69.说说你对版本管理的理解？常用的版本管理工具有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Git%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">70.</span> <span class="toc-text">70.说说你对Git的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E8%AF%B4%E8%AF%B4Git%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">71.</span> <span class="toc-text">71.说说Git常用的命令有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E8%AF%B4%E8%AF%B4-git-%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">72.</span> <span class="toc-text">72.说说 git 发生冲突的场景？如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">73.</span> <span class="toc-text">73.前端工程化的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74%E4%B8%BA%E4%BB%80%E4%B9%88-GUI-%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8EJS-%E5%BC%95%E6%93%8E%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">74.</span> <span class="toc-text">74为什么 GUI 渲染线程为什么与JS 引擎线程互斥</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/13/v2-%E4%B8%8Ev3-%E7%9A%84%E5%8C%BA%E5%88%AB/" title="v2 与v3 的区别">v2 与v3 的区别</a><time datetime="2023-03-13T03:20:39.000Z" title="Created 2023-03-13 11:20:39">2023-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/11/16/vue3-antd-admin%E5%90%AF%E5%8A%A8%E9%94%99%E8%AF%AF/" title="vue3-antd-admin启动错误">vue3-antd-admin启动错误</a><time datetime="2022-11-16T03:51:17.000Z" title="Created 2022-11-16 11:51:17">2022-11-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/11/16/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="面试题">面试题</a><time datetime="2022-11-16T03:51:17.000Z" title="Created 2022-11-16 11:51:17">2022-11-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/" title="深拷贝浅拷贝">深拷贝浅拷贝</a><time datetime="2022-10-21T08:31:43.000Z" title="Created 2022-10-21 16:31:43">2022-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/10/21/react%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/" title="react生成图片验证码">react生成图片验证码</a><time datetime="2020-10-21T11:20:19.000Z" title="Created 2020-10-21 19:20:19">2020-10-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By YaYa</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>