<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Angular 框架使用</title>
    <url>/2022/09/26/Angular%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Angular-框架"><a href="#Angular-框架" class="headerlink" title="Angular 框架"></a>Angular 框架</h1>]]></content>
  </entry>
  <entry>
    <title>css提升性能的方法</title>
    <url>/2019/11/24/css%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>为了展示多彩多样的页面效果，我们的每一个网页都离不开 css。大多数人认为，css 就是完成页面布局的，只要东西出来了，细节优化什么的不用在意。<br>这种想法式不正确的，利用好 css 优化，即使我们的不修改我们的 js 代码也可以使我们的代码性能有很大的提升</p>
<h1 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h1><h2 id="1-提高加载的性能"><a href="#1-提高加载的性能" class="headerlink" title="1. 提高加载的性能"></a>1. 提高加载的性能</h2><blockquote>
<p>想要提高加载的性能主要式从减少文件的体积、减少阻塞加载、提高并发方面入手</p>
</blockquote>
<ol>
<li>我们可以 使用的一些工具像 <strong>webpack</strong> 、<strong>gulp&#x2F;grunt</strong>，<strong>rollup</strong> 等模块化的工具 来 <strong><em>压缩 css</em></strong> 代码，使我们的文件变小，大大降低了浏览器的加载时间。</li>
<li>不要使用 <strong>@import</strong> ,css 样式文件有两种引入方式 一种是 link 元素 ，还有一种就是@import<br>@import 他会影响浏览器的并行下载 ，使我们的页面在加载的时候增加额外的延迟，增添了额外的往返耗时<br>而且多个@import 可能会导致下载顺序紊乱 他会先下载本文件 下载、解析并执行完才开始下载 import 中的文件</li>
</ol>
<h2 id="1-内联首屏关键-CSS"><a href="#1-内联首屏关键-CSS" class="headerlink" title="1. 内联首屏关键 CSS"></a>1. 内联首屏关键 CSS</h2><p>关键的 CSS 是一种技术，它提取并内嵌 CSS 以获得页面以上的内容。在 HTML 文档的 <head>中内联提取的样式，无需额外请求获取这些样式，并加快渲染速度。<br>外部引用 css 代码，在解析 html 结构过程中遇到外部 css 文件，才会开始下载 css 代码，再渲染，内联使渲染时间提前<br><strong>注意：</strong> 但是较大的 css 代码并不合适内联（初始拥塞窗口、没有缓存），而其余代码则采取外部引用方式</head></p>
<blockquote>
<p>确定关键的 CSS 并不完全准确，因为你需要对页面滚动之前在页面加载时看到的所有内容的位置进行假设（不同设备屏幕尺寸的位置有所不同）。这对于高度动态的网站来说是很困难的。即使不精确，它仍然可以带来性能的提升，我们可以通过 Critical、CriticalCSS 和 Penthouse 等工具自动化。</p>
</blockquote>
<h2 id="2-异步加载-CSS"><a href="#2-异步加载-CSS" class="headerlink" title="2. 异步加载 CSS"></a>2. 异步加载 CSS</h2><p>在 CSS 文件请求、下载、解析完成之前，CSS 会阻塞渲染，浏览器将不会渲染任何已处理的内容<br>前面加载内联代码后，后面的外部引用 css 则没必要阻塞浏览器渲染。我们就可以通过异步加载的方式提高速度</p>
<ol>
<li><p>用 js 将 link 标签插到 head 标签最后</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建link标签</span></span><br><span class="line"><span class="keyword">const</span> myCSS = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">myCSS.<span class="property">rel</span> = <span class="string">&quot;stylesheet&quot;</span>;</span><br><span class="line">myCSS.<span class="property">href</span> = <span class="string">&quot;mystyles.css&quot;</span>;</span><br><span class="line"><span class="comment">// 插入到header的最后位置</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">insertBefore</span>(</span><br><span class="line">  myCSS,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">childNodes</span>[<span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">childNodes</span>.<span class="property">length</span> - <span class="number">1</span>].<span class="property">nextSibling</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 link 标签 media 属性为 noexis，浏览器会认为当前样式表不适用当前类型，会在不阻塞页面渲染的情况下再进行下载。加载完成后，将 media 的值设为 screen 或 all，从而让浏览器开始解析 CSS</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">  <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">&quot;mystyles.css&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">media</span>=<span class="string">&quot;noexist&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">&quot;this.media=&#x27;all&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 rel 属性将 link 元素标记为 alternate 可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将 rel 设回 stylesheet</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">  <span class="attr">rel</span>=<span class="string">&quot;alternate stylesheet&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">&quot;mystyles.css&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">&quot;this.rel=&#x27;stylesheet&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-合理使用选择器"><a href="#3-合理使用选择器" class="headerlink" title="3. 合理使用选择器"></a>3. 合理使用选择器</h2><p>css 匹配的规则是从右往左开始匹配，例如#markdown .content h3 匹配规则如下：</p>
<ol>
<li>先找到 h3 标签元素</li>
<li>然后去除祖先不是.content 的元素</li>
<li>最后去除祖先不是#markdown 的元素</li>
</ol>
<p>如果嵌套的层级更多，页面中的元素更多，那么匹配所要花费的时间代价自然更高</p>
<p>所以我们在编写选择器的时候，可以遵循以下规则：</p>
<blockquote>
<p>不要嵌套使用过多复杂选择器，最好不要三层以上<br>使用 id 选择器就没必要再进行嵌套<br>通配符和属性选择器效率最低，避免使用</p>
</blockquote>
<h2 id="4-减少使用昂贵的属性"><a href="#4-减少使用昂贵的属性" class="headerlink" title="4. 减少使用昂贵的属性"></a>4. 减少使用昂贵的属性</h2><p>在页面发生重绘的时候，昂贵属性如 box-shadow&#x2F;border-radius&#x2F;filter&#x2F;透明度&#x2F;:nth-child 等，会降低浏览器的渲染性能</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>css 实现性能的方式可以从选择器嵌套、属性特性、减少 http 这三面考虑，同时还要注意 css 代码的加载顺序</p>
]]></content>
  </entry>
  <entry>
    <title>hello word</title>
    <url>/2017/09/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>css选择器</title>
    <url>/2017/09/26/css%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="1-css选择器"><a href="#1-css选择器" class="headerlink" title="1.css选择器"></a>1.css选择器</h1><p>在 CSS 中,选择器是一种模式,用于选择需要添加样式的元素。<br>当我们需要使用css对HTML页面中的元素实现一对一，一对多或者多对一的控制，这就需要用到CSS选择器。HTML页面中的元素的样式就是通过CSS选择器进行控制的。</p>
<p>我们常用的选择器有：</p>
<pre><code>1、标签名选择器：通过标签的名称找到指定标签
格式：元素名&#123; &#125;
2、类选择器：通过标签的class属性值选中指定标签,多个标签可以有相同的class值
格式：.d1&#123; &#125;
3、id选择器：通过id找到标签，一个html文件中id不能重复
格式： #id&#123;&#125;
4、派生选择器（后代选择器）：类似于路径，找到符合要求的标签，会匹配所有的后代标签
格式： ul li a&#123;&#125; #id li a&#123;&#125;
5、子元素选择器：和后代类似，但是只能获得子元素
格式： ul&gt;li&gt;a&#123;&#125;
6、分组选择器：可以将多种选择器结合到一起使用，用来统一设定样式
格式: h1,h2,#abc,.m&#123; &#125;
7、伪元素选择器 ：用于创建一些不在DOM树中的元素，并为其添加样式
::after  选取指定选择器的首行
::before
::first-letter  用于选取指定选择器的首字母
::first-line  选取指定选择器的首行
::selection
::placeholder
8、相邻同胞选择器 ： 选择紧接在.one 之后的所有.two元素 
格式 ： .one+.two
========================css3新增=============================
9、伪类选择器：元素处于某种状态时为其添加对应的样式，状态分为以下几种：
link 表示元素未被点击时的状态
hover 表示鼠标悬停时的状态  #id:hover&#123; &#125;
active 表示元素被点击时的状态
visited 表示元素被点击后的状态格式： 
:focus ：选择具有焦点的
:first-child：父元素的首个子元素
10、属性选择器 ： 选择带有某一个属性的元素 
[attribute] 选择带有attribute属性的元素
[attribute=value] 选择所有使用attribute=value的元素
[attribute~=value] 选择attribute属性包含value的元素
[attribute|=value]：选择attribute属性以value开头的元素
11、层次选择器（p~ul），选择前面有p元素的每个ul元素
</code></pre>
<p>点击查看<a href="https://www.runoob.com/cssref/css-selectors.html">更多</a></p>
<h1 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2.优先级"></a>2.优先级</h1><p>优先级一般是按 一下顺序排列的 ：<br>    内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器<br>如果我们想要某一个元素的外部样式权重最高   也就是覆盖其他同类样式的话 可以在属性后面加上  <code>!important</code>  </p>
<h1 id="3-继承属性"><a href="#3-继承属性" class="headerlink" title="3.继承属性"></a>3.继承属性</h1><p>在css中，继承是指给父元素设置一些属性，后代元素会自动拥有这些属性<br>常用的继承属性有一下几种：</p>
<p><strong>1、字体系列属性</strong><br>    font:组合字体<br>    font-family:规定元素的字体系列<br>    font-weight:设置字体的粗细<br>    font-size:设置字体的尺寸<br>    font-style:定义字体的风格<br>    font-variant:偏大或偏小的字体<br><strong>2、文本系列属性</strong><br>    text-indent：文本缩进<br>    text-align：文本水平对刘<br>    line-height：行高<br>    word-spacing：增加或减少单词间的空白<br>    letter-spacing：增加或减少字符间的空白<br>    text-transform：控制文本大小写<br>    direction：规定文本的书写方向<br>    color：文本颜色<br><strong>3、元素可见性</strong><br>    visibility<br><strong>4、表格布局属性</strong><br>    caption-side：定位表格标题位置<br>    border-collapse：合并表格边框<br>    border-spacing：设置相邻单元格的边框间的距离<br>    empty-cells：单元格的边框的出现与消失<br>    table-layout：表格的宽度由什么决定<br><strong>5、列表属性</strong><br>    list-style-type：文字前面的小点点样式<br>    list-style-position：小点点位置<br>    list-style：以上的属性可通过这属性集合<br><strong>6、引用</strong><br>    quotes：设置嵌套引用的引号类型<br><strong>7、光标属性</strong><br>    cursor：箭头可以变成需要的形状</p>
<p><strong>继承中比较特殊的几点：</strong><br>a 标签的字体颜色不能被继承<br>h1-h6标签字体的大下也是不能被继承的</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.html.cn/qa/css3/13444.html">链接1</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors">链接2</a></p>
]]></content>
  </entry>
  <entry>
    <title>react_router_dom V5与V6 的区别</title>
    <url>/2020/10/20/react-router-dom/</url>
    <content><![CDATA[<h2 id="1-v6-中-Switch-名称变为-Routes"><a href="#1-v6-中-Switch-名称变为-Routes" class="headerlink" title="1. v6 中 Switch 名称变为 Routes"></a>1. v6 中 Switch 名称变为 Routes</h2><p>代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Routes</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    .....</span></span><br><span class="line"><span class="language-xml"> 	 <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="2-v6-的变化"><a href="#2-v6-的变化" class="headerlink" title="2. v6 的变化"></a>2. v6 <Route>的变化</Route></h2><p>不再支持子组件和 component , 改为 element</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/home&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Index</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/<span class="title class_">Route</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/login&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Login&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br></pre></td></tr></table></figure>






<p>改为</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/home&quot;</span> element=&#123; <span class="language-xml"><span class="tag">&lt;<span class="name">Index</span> /&gt;</span></span> &#125;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/<span class="title class_">Route</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/login&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span> &lt;<span class="attr">Login</span> /&gt;</span> &#125;&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br></pre></td></tr></table></figure>




<p>注：</p>
<p>element 的值为组件标签，不要忘记写成标签形式</p>
<p>Route 标签必须包含在Routes标签里，会不然报错</p>
<h2 id="3-v6-中，exact-属性不再需要"><a href="#3-v6-中，exact-属性不再需要" class="headerlink" title="3. v6 中，exact 属性不再需要"></a>3. v6 中，exact 属性不再需要</h2><p>v6 内部算法改变，不再需要加exact实现精确匹配路由，默认就是匹配完整路径。</p>
<p>如果需要旧的行为，路径后加&#x2F;*</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/products/*&quot;</span> element=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">Products</span> /&gt;</span></span>&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/products/:productId&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProductDetail</span> /&gt;</span>&#125; /&gt;</span></span><br></pre></td></tr></table></figure>



<p>route属性  路由是否区分大小写 </p>
<p>caseSensitive&#x3D;{true}</p>
<h2 id="4-v6-中，Route-先后顺序不再重要，React-Router-能够自动找出最优匹配路径"><a href="#4-v6-中，Route-先后顺序不再重要，React-Router-能够自动找出最优匹配路径" class="headerlink" title="4. v6 中，Route 先后顺序不再重要，React Router 能够自动找出最优匹配路径"></a>4. v6 中，Route 先后顺序不再重要，React Router 能够自动找出最优匹配路径</h2><h2 id="5-v6-保留Link，NavLink，-但是NavLink的activeClassName属性被移除"><a href="#5-v6-保留Link，NavLink，-但是NavLink的activeClassName属性被移除" class="headerlink" title="5.v6 保留Link，NavLink， 但是NavLink的activeClassName属性被移除"></a>5.v6 保留Link，NavLink， 但是NavLink的activeClassName属性被移除</h2><p>删除了 activeClassName 样式，如果想自己给它设置想要的highligh样式.</p>
<p>可以通过style属性修改actived的状态, 通过箭头函数接收到isActive参数值;</p>
<p>style接收一个css样式数据返回值进行修改<NavLink> active状态样式。</NavLink></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Invoices</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">display:</span> &quot;<span class="attr">flex</span>&quot; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">style</span>=<span class="string">&#123;(&#123;</span> <span class="attr">isActive</span> &#125;) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  return &#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  display: &quot;block&quot;,</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  margin: &quot;1rem 0&quot;,</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  color: isActive ? &quot;red&quot; : &quot;&quot;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            &#125;;</span></span><br><span class="line"><span class="language-xml">    </span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">to=&#123;`/invoices`&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">NavLink</span> className=&#123;<span class="function">(<span class="params">&#123; isActive &#125;</span>) =&gt;</span> isActive ? <span class="string">&quot;red&quot;</span> : <span class="string">&quot;blue&quot;</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>


<h2 id="6-v6-移除-Redirect组件，改为使用-Navigate"><a href="#6-v6-移除-Redirect组件，改为使用-Navigate" class="headerlink" title="6. v6 移除 Redirect组件，改为使用 Navigate:"></a>6. v6 移除 Redirect组件，改为使用 Navigate:</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">#<span class="number">5</span></span><br><span class="line">&lt;<span class="title class_">Redirect</span> to=<span class="string">&quot;/home&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">#<span class="number">6</span></span><br><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/&quot;</span> element =&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">replace</span> <span class="attr">to</span>=<span class="string">&quot;/welcome&quot;</span> /&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure>



<p><Navigate replace to="/welcome"> 是对旧的 Redirect 的完整取代。</Navigate></p>
<p>replace 属性也可以省略，不过行为由 replace 改为 push</p>
<h2 id="7-v6-嵌套路由改为相对匹配"><a href="#7-v6-嵌套路由改为相对匹配" class="headerlink" title="7. v6 嵌套路由改为相对匹配"></a>7. v6 嵌套路由改为相对匹配</h2><p>嵌套路由必须放在<Routes> </Routes>中，且使用相对路径，不再像 v5 那样必须提供完整路径，因此路径变短。</p>
<pre><code>&lt;Route path=&#39;/about&#39; element=&#123;&lt;About /&gt;&#125;&gt;
    &lt;Route index element=&#123;&lt;Address /&gt;&#125; /&gt;

    &lt;Route path=&#39;address&#39; element=&#123;&lt;Address /&gt;&#125;&gt;&lt;/Route&gt;

    &lt;Route path=&#39;information&#39; element=&#123;&lt;Information /&gt;&#125;&gt;&lt;/Route&gt;

    &lt;Route path=&#39;joinus&#39; element=&#123;&lt;Join /&gt;&#125;&gt;&lt;/Route&gt;
&lt;/Route&gt;
</code></pre>
<h2 id="8-使用Outlet组件，此组件是一个占位符，告诉-React-Router-嵌套的内容应该放到哪里。"><a href="#8-使用Outlet组件，此组件是一个占位符，告诉-React-Router-嵌套的内容应该放到哪里。" class="headerlink" title="8.使用Outlet组件，此组件是一个占位符，告诉 React Router 嵌套的内容应该放到哪里。"></a>8.使用Outlet组件，此组件是一个占位符，告诉 React Router 嵌套的内容应该放到哪里。</h2><p>import {Outlet} from “react-router-dom”;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Welcome</span>=(<span class="params"></span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Welcome</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="9-使用index-指定默认路由-或者path为空"><a href="#9-使用index-指定默认路由-或者path为空" class="headerlink" title="9. 使用index 指定默认路由, 或者path为空"></a>9. 使用index 指定默认路由, 或者path为空</h2><p>当嵌套路由有多个子路由的时候，可以增加 index 属性来指定默认路由。</p>
<pre><code>function App()

  return (
    &lt;Routes&gt;

      &lt;Route path=&quot;/&quot; element=&#123;&lt;Layout /&gt;&#125;&gt;

      &lt;Route index element=&#123;&lt;About /&gt;&#125; /&gt;

      &lt;Route path=&quot;user&quot; element=&#123;&lt;User /&gt;&#125; /&gt;

      &lt;Route path=&quot;about&quot; element=&#123;&lt;About /&gt;&#125; /&gt;

      &lt;/Route&gt;

    &lt;/Routes&gt;
       );

&#125;
</code></pre>
<p>或者</p>
<p>设置path为空，来指定默认路由，代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> router  =[&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line"></span><br><span class="line">  element :<span class="language-xml">&lt;Home/ &gt;,</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  children: [</span></span><br><span class="line"><span class="language-xml">&#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">path:&quot;&quot;,</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">element:<span class="tag">&lt;<span class="name">News</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;,</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">path: &quot; news &quot; ,</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">element:<span class="tag">&lt;<span class="name">News</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">  ]</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;]</span></span><br></pre></td></tr></table></figure>






<h2 id="10-v6-用useNavigate实现编程式导航，useHistory被移除"><a href="#10-v6-用useNavigate实现编程式导航，useHistory被移除" class="headerlink" title="10. v6 用useNavigate实现编程式导航，useHistory被移除"></a>10. v6 用useNavigate实现编程式导航，useHistory被移除</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useNavigate&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> navigate = <span class="title function_">useNavigate</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">navigate</span>(<span class="string">&quot;/welcome&quot;</span>);   <span class="comment">// push</span></span><br><span class="line"> <span class="title function_">navigate</span>(<span class="string">&#x27;/b&#x27;</span>, &#123; <span class="attr">state</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;zhou&#x27;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure>


<p>如果要重定向:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">navigate</span>(<span class="string">&quot;/welcome&quot;</span>,&#123;<span class="attr">replace</span>:<span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>



<p>除此之外，还可以使用navigate(-1)后退到前一页，使用navigate(-2)后退到前一页的前一页，navigate(1)前向导航，依此类推。</p>
<p>使用 useLocation 接收 useNavigate传递过来的值</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收跳转传过来的值</span></span><br><span class="line"><span class="keyword">import</span> &#123; useLocation &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> location = <span class="title function_">useLocation</span>()</span><br><span class="line"><span class="keyword">const</span> &#123; state &#125; = location</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location, state);</span><br></pre></td></tr></table></figure>





<h2 id="11-hooks-中获取参数的方法"><a href="#11-hooks-中获取参数的方法" class="headerlink" title="11. hooks 中获取参数的方法"></a>11. hooks 中获取参数的方法</h2><p>useParams</p>
<p>返回当前动态路由参数 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Profile</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> params = <span class="title function_">useParams</span>()</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(params.<span class="property">userId</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>useSearchParams</p>
<p>使用 useSearchParams hook 来访问查询参数(&#x2F;xx&#x2F;xx?userId&#x3D;123)。其用法和 useState 类似，会返回当前对象和更改它的方法。</p>
<p>更改 searchParams 时，必须传入所有的查询参数，否则会覆盖已有参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Profile</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> params = <span class="title function_">useSearchParams</span>()</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(params.<span class="property">userId</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="12-useRoutes-声明式的路由配置方式"><a href="#12-useRoutes-声明式的路由配置方式" class="headerlink" title="12. useRoutes 声明式的路由配置方式"></a>12. useRoutes 声明式的路由配置方式</h2><p>声明式路由中，不能写index, 可以让path: “” , 来实现显示默认组件;</p>
<p>useRoutes函数，会返回已经渲染好的路由元素</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="title function_">useRoutes</span>([</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Dashboard</span> /&gt;</span></span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">DashboardMessages</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/messages&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">DashboardMessages</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&quot;/tasks&quot;</span>, <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">DashboardTasks</span> /&gt;</span></span> &#125;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&quot;/team&quot;</span>, <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">AboutPage</span> /&gt;</span></span> &#125;</span><br><span class="line"></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>js数据类型</title>
    <url>/2020/08/11/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>在<code>JavaScript</code>中我们可以把数据分为两种类型</p>
<ul>
<li>基本数据类型</li>
<li>复杂数据类型</li>
</ul>
<h1 id="一、基本数据类型"><a href="#一、基本数据类型" class="headerlink" title="一、基本数据类型"></a>一、基本数据类型</h1><ol>
<li><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>数值最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x 开头）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span>; <span class="comment">// 10进制的55</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">070</span>; <span class="comment">// 8 进制的 56</span></span><br><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xa</span>; <span class="comment">//16 进制的 10</span></span><br></pre></td></tr></table></figure>

<p>浮点类型则在数值汇总必须包含小数点，还可通过科学计数法表示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum3 = <span class="number">0.1</span>; <span class="comment">// 有效，但不推荐</span></span><br><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于 31250000</span></span><br></pre></td></tr></table></figure>

<p>在数值类型中，存在一个特殊数值 NaN，意为“不是数值”，用于表示本来要返回数值的操作失败了（而不是抛出错误）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> / <span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span> / +<span class="number">0</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>字符串可以使用双引号（”）、单引号（’）或反引号（&#96;）标示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&quot;Jacob&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">`Jingleheimerschmidt`</span>;</span><br></pre></td></tr></table></figure>
<p>字符串是不可变的，意思是一旦创建，它们的值就不能变了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>; <span class="comment">// 先销毁再创建</span></span><br></pre></td></tr></table></figure></li>
<li><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><pre><code>Boolean（布尔值）类型有两个字面值： true 和false

通过Boolean可以将其他类型的数据转化成布尔值
</code></pre>
</li>
</ol>
<p>规则如下：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为 true 的值</th>
<th>转换为 false 的值</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>非空字符串</td>
<td>“”</td>
</tr>
<tr>
<td>Number</td>
<td>非零数值（包括无穷值）</td>
<td>0 、 NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任意对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>N&#x2F;A （不存在）</td>
<td>undefined</td>
</tr>
</tbody></table>
<ol start="4">
<li><h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h4><p> Undefined 类型只有一个值，就是特殊值 undefined。当使用 var或 let声明了变量但没有初始化时，就相当于给变量赋予了 undefined值<br> 包含undefined 值的变量跟未定义变量是有区别的</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 没有声明过这个变量，报错</span></span><br></pre></td></tr></table></figure></li>
<li><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p> Null类型同样只有一个值，即特殊值 null</p>
<p> 逻辑上讲， null 值表示一个空对象指针，这也是给typeof传一个 null 会返回 “object” 的原因</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> car); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="comment">// undefined 值是由 null值派生而来</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p> 只要变量要保存对象，而当时又没有那个对象可保存，就可用 null来填充该变量</p>
</li>
<li><h4 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h4><p> Symbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> otherGenericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(genericSymbol == otherGenericSymbol); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooSymbol == otherFooSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="二、引用类型"><a href="#二、引用类型" class="headerlink" title="二、引用类型"></a>二、引用类型</h1><p>复杂类型统称为<code>Object</code>，我们这里主要讲述下面三种：</p>
<ul>
<li>Object</li>
<li>Array</li>
<li>Function</li>
</ul>
<h3 id="1-Object"><a href="#1-Object" class="headerlink" title="1. Object"></a>1. Object</h3><p>创建<code>object</code>常用方式为对象字面量表示法，属性名可以是字符串或数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-Array"><a href="#2-Array" class="headerlink" title="2. Array"></a>2. Array</h3><p><code>JavaScript</code>数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。并且，数组也是动态大小的，会随着数据添加而自动增长</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="number">2</span>, &#123;<span class="attr">age</span>: <span class="number">20</span> &#125;]</span><br><span class="line">colors.<span class="title function_">push</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h3 id="3-Function"><a href="#3-Function" class="headerlink" title="3 .Function"></a>3 .Function</h3><p>函数实际上是对象，每个函数都是 <code>Function</code>类型的实例，而 <code>Function</code>也有属性和方法，跟其他引用类型一样</p>
<p>函数存在三种常见的表达方式：</p>
<ul>
<li>函数声明</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span> (num1, num2) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>函数表达式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>箭头函数</li>
</ul>
<p>函数声明和函数表达式两种方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="其他引用类型"><a href="#其他引用类型" class="headerlink" title="其他引用类型"></a>其他引用类型</h3><p>除了上述说的三种之外，还包括<code>Date</code>、<code>RegExp</code>、<code>Map</code>、<code>Set</code>等……</p>
<h1 id="三-、存储区别"><a href="#三-、存储区别" class="headerlink" title="三 、存储区别"></a>三 、存储区别</h1><p>基本数据类型和引用数据类型存储在内存中的位置不同：</p>
<ul>
<li>基本数据类型存储在栈中</li>
<li>引用类型的对象存储于堆中</li>
</ul>
<p>当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值</p>
<p>下面来举个例子</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = a; <span class="comment">// 赋值操作</span></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10值</span></span><br></pre></td></tr></table></figure>



<p><code>a</code>的值为一个基本类型，是存储在栈中，将<code>a</code>的值赋给<code>b</code>，虽然两个变量的值相等，但是两个变量保存了两个不同的内存地址</p>
<p>下图演示了基本类型赋值的过程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.vue-js.com/906ffb90-6463-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&quot;Xxx&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">name</span>); <span class="comment">// xxx</span></span><br></pre></td></tr></table></figure>



<p><strong>引用类型数据存放在堆中，每个堆内存对象都有对应的引用地址指向它，引用地址存放在栈中。</strong></p>
<p><code>obj1</code>是一个引用类型，在赋值操作过程汇总，实际是将堆内存对象在栈内存的引用地址复制了一份给了<code>obj2</code>，实际上他们共同指向了同一个堆内存对象，所以更改<code>obj2</code>会对<code>obj1</code>产生影响</p>
<p>下图演示这个引用类型赋值过程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.vue-js.com/a34bdd10-6463-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>声明变量时不同的内存地址分配：</p>
<ul>
<li>简单类型的值存放在栈中，在栈中存放的是对应的值</li>
<li>引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址</li>
</ul>
</li>
<li><p>不同的类型数据导致赋值变量时的不同：</p>
<ul>
<li>简单类型赋值，是生成相同的值，两个对象对应不同的地址</li>
<li>复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象</li>
</ul>
</li>
<li><p>在复杂类型赋值中 ，当修改赋值后的变量值的时候 ，因为他们是两个变量指向的同一个对象 原数据也会跟着改变，如果想要原数据不变   ，这个时候可以使用<strong>深拷贝</strong>：</p>
<ul>
<li><p>使用JSON.stringify()以及JSON.parse()</p>
</li>
<li><p>通过for in实现 循环遍历手动添加</p>
</li>
<li><p>数组可以使用 concat </p>
<ul>
<li>使用concat合并数组，会返回一个新的数组。<br>对象是一个引用数据类型 普通的复制是一个浅拷贝</li>
</ul>
</li>
<li><p>循环递归</p>
</li>
<li><p>&#96;&#96;&#96;js<br>function deepClone(obj, hash &#x3D; new WeakMap()) {<br>  if (obj &#x3D;&#x3D;&#x3D; null) return obj; &#x2F;&#x2F; 如果是null或者undefined我就不进行拷贝操作<br>  if (obj instanceof Date) return new Date(obj);<br>  if (obj instanceof RegExp) return new RegExp(obj);<br>  &#x2F;&#x2F; 可能是对象或者普通的值  如果是函数的话是不需要深拷贝<br>  if (typeof obj !&#x3D;&#x3D; “object”) return obj;<br>  &#x2F;&#x2F; 是对象的话就要进行深拷贝<br>  if (hash.get(obj)) return hash.get(obj);<br>  let cloneObj &#x3D; new obj.constructor();<br>  &#x2F;&#x2F; 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身<br>  hash.set(obj, cloneObj);<br>  for (let key in obj) {<br>if (obj.hasOwnProperty(key)) {<br>  &#x2F;&#x2F; 实现一个递归拷贝<br>  cloneObj[key] &#x3D; deepClone(obj[key], hash);<br>}<br>  }<br>  return cloneObj;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      </span><br><span class="line">      hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链。</span><br><span class="line">      </span><br><span class="line">      [深拷贝更多了解](https://isyayaya.github.io/2022/10/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/) </span><br><span class="line"></span><br><span class="line"># 四、判断数据类型的方法</span><br><span class="line"></span><br><span class="line">## **1、typeof**</span><br><span class="line"></span><br><span class="line">　　typeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。</span><br><span class="line"></span><br><span class="line">　　返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：string、number、boolean、symbol、undefined、object、function 等。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>typeof<code> </code>‘a’<code>; </code>&#x2F;&#x2F; string 有效<code>typeof` `1; </code>&#x2F;&#x2F; number 有效<code>typeof` `true</code>; <code>//boolean 有效</code>typeof<code> </code>Symbol(); <code>// symbol 有效</code>typeof<code> </code>undefined; <code>//undefined 有效</code>typeof<code> </code>new<code> </code>Function(); <code>// function 有效</code>typeof<code> </code>null<code>; </code>&#x2F;&#x2F;object 无效<code>typeof` `[1] ; </code>&#x2F;&#x2F;object 无效<code>typeof` `new` `RegExp(); </code>&#x2F;&#x2F;object 无效<code>typeof` `new` `Date(); </code>&#x2F;&#x2F;object 无效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**总结：**</span><br><span class="line"></span><br><span class="line">- 对于基本类型，除 null 以外，均可以返回正确的结果。</span><br><span class="line">- 对于引用类型，除 function 以外，一律返回 object 类型。</span><br><span class="line">- 对于 null ，返回 object 类型。</span><br><span class="line">- 对于 function 返回 function 类型。</span><br><span class="line"></span><br><span class="line">　　其中，null 有属于自己的数据类型 Null ，引用类型中的数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型。</span><br><span class="line"></span><br><span class="line">## **2、instanceof**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">　　instanceof 检测的是原型，表达式为：`A instanceof B`，如果 A 是 B 的实例，则返回 true，否则返回 false。</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">[] ``instanceof` `Array; ``// true``new` `Date() ``instanceof` `Date;``// true`` ` `function` `Person()&#123;&#125;;``new` `Person() ``instanceof` `Person;``//true`` ` `[] ``instanceof` `Object; ``// true``new` `Date() ``instanceof` `Object;``// true``new` `Person ``instanceof` `Object;``// true</span><br></pre></td></tr></table></figure>

<p>　　虽然 instanceof 能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例，为什么呢？</p>
<p>　 从 instanceof 能够判断出 [ ].<strong>proto</strong> 指向 Array.prototype，而 Array.prototype.<strong>proto</strong> 又指向了Object.prototype，最终 Object.prototype.<strong>proto</strong> 指向了null，标志着原型链的结束。因此，[ ]、Array、Object 就在内部形成了一条原型链，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/941b17a88de44dd2a6778cdf738a82b4.png" alt="img"></p>
<p>　　 从原型链可以看出，[] 的 <strong>proto</strong> 直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。</p>
<p>　　因此，instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</p>
<p>　 针对数组的这个问题，ES5 提供了 Array.isArray() 方法 。该方法用以确认某个对象本身是否为 Array 类型，而不区分该对象在哪个环境中创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if` `(Array.isArray(value))&#123;``  ``//对数组执行某些操作``&#125;</span><br></pre></td></tr></table></figure>

<p>　　Array.isArray() 本质上检测的是对象的 [[Class]] 值。</p>
<p>　　[[Class]] 是对象的一个内部属性，里面包含了对象的类型信息，其格式为 [object Xxx]，Xxx 就是对应的具体类型 。对于数组而言，[[Class]] 的值就是 [object Array] 。</p>
<h2 id="3、constructor"><a href="#3、constructor" class="headerlink" title="3、constructor"></a><strong>3、constructor</strong></h2><p>　　当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/481e49f4bddb49909f8b694e41cd6e00.png" alt="image-20221116085136260"></p>
<p>　　当执行 var f &#x3D; new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 f.constructor &#x3D;&#x3D; F</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/4eaf44f6cc604d87b8ecf0822ec4a430.png" alt="image-20221116085105251"></p>
<p>　　可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。</p>
<p>　　同样，JavaScript 中的内置对象在内部构建时也是这样做的，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8889e53d3e8c4d078837e10265a4ddbf.png" alt="image-20221116085021720"></p>
<p><strong>总结：</strong></p>
<p>　　1. null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</p>
<p>　　2. 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object。</p>
<h2 id="4、toString"><a href="#4、toString" class="headerlink" title="4、toString"></a><strong>4、toString</strong></h2><p>　　toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。</p>
<p>　　对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call &#x2F; apply 来调用才能返回正确的类型信息。</p>
<p>　　语法：<code>Object.prototype.toString.call(value)</code>;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString.call(``&#x27;&#x27;``) ;  ``// [object String]``Object.prototype.toString.call(1) ;  ``// [object Number]``Object.prototype.toString.call(``true``) ; ``// [object Boolean]``Object.prototype.toString.call(Symbol()); ``//[object Symbol]``Object.prototype.toString.call(undefined) ; ``// [object Undefined]``Object.prototype.toString.call(``null``) ; ``// [object Null]``Object.prototype.toString.call(``new` `Function()) ; ``// [object Function]``Object.prototype.toString.call(``new` `Date()) ; ``// [object Date]``Object.prototype.toString.call([]) ; ``// [object Array]``Object.prototype.toString.call(``new` `RegExp()) ; ``// [object RegExp]``Object.prototype.toString.call(``new` `Error()) ; ``// [object Error]``Object.prototype.toString.call(document) ; ``// [object HTMLDocument]``Object.prototype.toString.call(window) ; ``//[object global] window 是全局对象 global 的引用</span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>react生成图片验证码</title>
    <url>/2020/10/21/react%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<p>​</p>
<p>前端开发过程中在与后端对接之前需要自己先造出一些数据，比如：mock等<br>图片验证码同样也需要前端自己先生成。</p>
<p>使用插件<br>react-captcha-code 这是一个基于React(依赖react, react-dom) 和 Canvas 的小插件</p>
<p>样式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/ff8d8879e9204806ad54d01925d9f938.png"></p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install react-captcha-code --save</span><br></pre></td></tr></table></figure>
<p>属性和方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>必填</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>height</td>
<td>number</td>
<td>否</td>
<td>40</td>
<td>图片高度</td>
</tr>
<tr>
<td>width</td>
<td>number</td>
<td>否</td>
<td>100</td>
<td>图片宽度</td>
</tr>
<tr>
<td>bgColor</td>
<td>string</td>
<td>否</td>
<td>#DFF0D8</td>
<td>背景颜色</td>
</tr>
<tr>
<td>charNum</td>
<td>number</td>
<td>否</td>
<td>4</td>
<td>验证码字符个数</td>
</tr>
<tr>
<td>fontSize</td>
<td>number</td>
<td>否</td>
<td>25</td>
<td>字体大小</td>
</tr>
<tr>
<td>onChange</td>
<td>function</td>
<td></td>
<td>是</td>
<td>点击验证码的回调，初始加载也会调用，返回验证码值</td>
</tr>
<tr>
<td>className</td>
<td>string</td>
<td>否</td>
<td></td>
<td>样式名</td>
</tr>
</tbody></table>
<p>示例</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Captcha</span> <span class="keyword">from</span> <span class="string">&#x27;react-captcha-code&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="attr">title</span>: <span class="string">&#x27;Basic&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Basic</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">captcha</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;captcha:&#x27;</span>, captcha);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Captcha</span> <span class="attr">charNum</span>=<span class="string">&#123;4&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;handleClick&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Basic</span>;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/xguoz/p/13163867.html">原文链接:我的故事没编好 - 博客园 </a></p>
<p>​</p>
]]></content>
  </entry>
  <entry>
    <title>v2 与v3 的区别</title>
    <url>/2023/03/13/v2-%E4%B8%8Ev3-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>首先我们说区别的时候需要先了解一下vue  vue 内部根据功能可以分为三大模块<br>第一个我们把他叫做响应性  也就是 reactivity<br>第二个叫做运行时  也就是 runtime<br>第三个叫做编辑器  也就是 complier<br>除了三个大的模块 还有一些composition Api 还有一些小的变化<br>那么我们说v2和v3的区别就从这几点说起<br>首先先说响应性  针对vue2 来说 他是通过 Object.defineProperty 来实现响应性的  它有一个作用 就是去监听指定对象的 指定属性的一个 getter 的行为和setter 行为  但是使用这个他是会出现一些问题的 就比如 当我们给data 新增一个对象 person  一旦我们给person这个对象新增一个属性的时候 他就不会是响应性的   之所以出现这个问题的原因 就是因为vue2 中 Object.definproperty的内部 它没有办法监听到我们新增的这个属性  所以说在vue2中 他又提供了一个方法叫做 Vue.$set 通过这个方法解决这个问题  但这明显是不合理的 所以在vue3中 引入了反射（Reflect）和代理（proxy）的一个概念  我们可以利用proxy直接代理一个普通对象  得到一个proxy 实例（代理对象）在vue3中我们把这个过程叫做 reactive 方法 但是proxy 它只能代理复杂数据类型的一个响应性  所以说 vue又额外提供了一个方法叫做 ref 的方法 用来处理 简单的数据类型的响应性， 这个方法在本质上并没有进行数据的监听而是构建了一个叫做 Reflmpl 的类， 通过 set 和get 标记了这个类里面的value方法   以此来进行实现  所以说我们的ref 必须使用  .value 触发 之所以这么做本质上就是在调用value 函数  </p>
<p>接下来就是运行时  ： 运行时大多时候指的时我们的renderer（渲染器）渲染器 本身是一个对象 内部有三个方法  其中我们最关注的方法就是render方法 也就是渲染函数 ， vue3中为了保证宿主函数 和渲染逻辑的一个分离 把所有与宿主环境相关的逻辑都进行了一个抽离 通过接口的形式进行传递 这样的目的就是为了解绑宿主环境和渲染逻辑   以保证vue 在非浏览器端宿主环境的一个正常渲染  </p>
<p>然后时 编译器 ： vue中的compiler 其实是一个DSL（特定领域下专用语言编译器）其目的是为了把template 模板编译成为render 函数 。 逻辑主要分为三大步 ：parse ，transform 和generator  pass主要的作用就是为了把tempalte  转化为AST，也就是抽象语法树   transform 可以把 AST 转化为 JavaScript AST  最后由generator 把js AST 转换为 render 函数 转化过程中会涉及到一些复杂的概念  比如说 有限自动状态机</p>
<p>除此之外还涉及到了一些其他的变化<br>例如之前说的composition API  在v2 跟v3中也是不一样的 比如说最初的composition API 以 setup 函数作为入口 而setup函数 则必须要返回两种类型的值 其中第一种叫做对象  第二种叫做函数  当setup 函数返回一个对象的时候  对象中的数据和方法 可以在template 里面去进行使用 当 setup 中返回一个函数的时候  那么这个函数 会被作为我们的render 函数 。但是这种setup 函数的形式其实并不好因为如果所有的逻辑都放在setup函数之中 那么就 所以说在vue3.2的时候还新增了一个叫做 <code>&lt;script setup&gt; </code> 的语法糖尝试去解决这个问题  </p>
<p>还有 Fragment ，teleport ， Suspense  等等 </p>
]]></content>
  </entry>
  <entry>
    <title>vue3-antd-admin启动错误</title>
    <url>/2022/11/16/vue3-antd-admin%E5%90%AF%E5%8A%A8%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>1、启动vue3-antd-admin项目时报以下错误，则缺少esbuild.exe所致，所以我们需要在以下目录安装<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/35278dc359384eb2b161799f376cc0ce.png" alt="在这里插入图片描述"></p>
<p>2、打开报错文件的目录，在cmd里输入 node .&#x2F;node_modules&#x2F;esbuild&#x2F;install.js</p>
<p>3、完成； 重启项目：npm run dev</p>
]]></content>
  </entry>
  <entry>
    <title>元素水平垂直居中的方法</title>
    <url>/2018/11/24/%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在开发中我们经常会遇到需要让某个元素在水平和垂直方向居中 ，像登录页面那样的亦或是弹窗。这时候居中就是一个非常基础但是又非常重要的应用场景。在此列举几个常用的居中方法，记录一下。<br>我们把居中的方法分为两大类 ：</p>
<ul>
<li>已知宽高</li>
<li>未知宽高</li>
</ul>
<h2 id="1-实现方式"><a href="#1-实现方式" class="headerlink" title="1.实现方式"></a>1.实现方式</h2><ol>
<li><h4 id="利用定位-margin：auto"><a href="#利用定位-margin：auto" class="headerlink" title="利用定位 + margin：auto"></a>利用定位 + margin：auto</h4><p>给父级组件一个相对定位 <code>position: relative;</code><br>给子组件一个绝对定位 <code> position: absolute</code><br>四个定位属性的值全部给 0 这个时候如果子级没有设置宽高，则会被拉开到和父级一样宽高，<br>如果设置了宽高的话，宽高会按照我们的设置来显示，但是实际上子级的虚拟占位已经撑满了整个父级，这时候再给它一个 margin：auto 它就可以上下左右都居中了</p>
</li>
<li><h4 id="利用定位-margin：负值"><a href="#利用定位-margin：负值" class="headerlink" title="利用定位 + margin：负值"></a>利用定位 + margin：负值</h4><p>设置父元素为相对定位， 子元素移动自身 50%实现水平垂直居中 ,就是说 子元素上移、右移父元素的 50% 然后再左移下移自身的 50% ，这些的前提是知道子元素自身的宽高 ，但不要求父元素的宽高</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="利用定位-tramsform"><a href="#利用定位-tramsform" class="headerlink" title="利用定位 + tramsform"></a>利用定位 + tramsform</h4><p>这个是方法二的替代方法 <code>transform: translate(-50%,-50%);</code> 这个属性可以代替</p>
<p>margin-left: -50px;<br>margin-top: -50px;</p>
<p><code>transform</code><br>可以旋转或者移动元素 <code>translate(-50%,-50%)</code>就相当于横轴纵轴个移动自身的 50%<br>因为我们的移动都是移动 50% 用百分比移动的所以 这个方法父级、子级的宽高都可以不知道</p>
</li>
<li><h4 id="table-布局"><a href="#table-布局" class="headerlink" title="table 布局"></a>table 布局</h4><p>设置父元素为 display:table-cell，子元素设置 display: inline-block。利用 vertical 和 text-align 可以让所有的行内块级元素水平垂直居中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: skyblue;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h4><p>flex 弹性盒子 这个是 css3 的新特性<br>给父级一个<code>display:flex</code> 盒子内部的元素将会按照 flex 进行布局<br>然后给他俩 flex 的方法</p>
<ul>
<li>align-items: center 表示这些元素将相对于本容器水平居中</li>
<li>justify-content: center 也是同样的道理垂直居中</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="grid-布局"><a href="#grid-布局" class="headerlink" title="grid 布局"></a>grid 布局</h4><p>grid 网格布局根 flex 布局一样的简单粗暴</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>响应式布局</title>
    <url>/2019/10/27/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="什么是响应式？"><a href="#什么是响应式？" class="headerlink" title="什么是响应式？"></a>什么是响应式？</h1><p>响应式网站设计（Responsive Web design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整</p>
<p><strong>响应式网站常见特点：</strong></p>
<ul>
<li><p>同时适配 PC + 平板 + 手机等</p>
</li>
<li><p>标签导航在接近手持终端设备时改变为经典的抽屉式导航</p>
</li>
<li><p>网站的布局会根据视口来调整模块的大小和位置</p>
</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>面对不同分辨率设备灵活性强</li>
<li>能够快捷解决多设备显示适应问题</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>仅适用布局、信息、框架并不复杂的部门类型网站</li>
<li>兼容各种设备工作量大，效率低下</li>
<li>代码累赘，会出现隐藏无用的元素，加载时间加长</li>
<li>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</li>
<li>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</li>
</ul>
<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>刚刚说过什么是响应式<br>响应式：响应不同屏幕设备合适地展现网页效果的方式或着手段。、<br>就是说我们用任何发方法能让我们的布局在不同的设备上正常显示就行了<br>我们可以使用百分比 使用 rem 自适应 使用 vw&#x2F;vh 弹性盒子 都可以做到响应式处理</p>
<blockquote>
<p>（vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度。 任意层级元素，在使用vw单位的情况下，1vw都等于视图宽度的百分之一） 他跟100%很像 不建议使用</p>
</blockquote>
<blockquote>
<p>rem是相对于根元素html的font-size属性，默认情况下浏览器字体大小为16px，此时1rem &#x3D; 16px。可以利用前面提到的媒体查询，针对不同设备分辨率改变font-size的值，如下：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">414px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">375px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">320px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了更准确监听设备可视窗口变化，我们可以在css之前插入script标签，内容如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态为根元素设置字体大小</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">init</span> () &#123;</span><br><span class="line">    <span class="comment">// 获取屏幕宽度</span></span><br><span class="line">    <span class="keyword">var</span> width = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span></span><br><span class="line">    <span class="comment">// 设置根元素字体大小。此时为宽的10等分</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">fontSize</span> = width / <span class="number">10</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首次加载应用，设置一次</span></span><br><span class="line"><span class="title function_">init</span>()</span><br><span class="line"><span class="comment">// 监听手机旋转的事件的时机，重新设置</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;orientationchange&#x27;</span>, init)</span><br><span class="line"><span class="comment">// 监听手机窗口变化，重新设置</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, init)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无论设备可视窗口如何变化，始终设置rem为width的1&#x2F;10，实现了百分比布局<br>除此之外，我们还可以利用主流UI框架，如：element ui、antd提供的栅格布局实现响应式</p>
</blockquote>
<p>css3 还出了一个<strong>媒体查询</strong>的方式 她就跟 if 判断一样，可以通过设置不同的媒体条件，并且根据对应的条件 给响应符合条件的媒体调用响应的样式<br>使用方法 ：<br>例： 当视口在375px - 600px之间，设置特定字体大小18px</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen (<span class="attribute">min-width</span>: <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更过详情点击<a href="https://www.runoob.com/cssref/css3-pr-mediaquery.html">这里</a></p>
]]></content>
  </entry>
  <entry>
    <title>什么是回流与重绘？</title>
    <url>/2019/01/10/%E5%9B%9E%E6%B5%81-%E9%87%8D%E7%BB%98/</url>
    <content><![CDATA[<h2 id="一、什么是回流与重绘"><a href="#一、什么是回流与重绘" class="headerlink" title="一、什么是回流与重绘"></a>一、什么是回流与重绘</h2><p> 他们就是浏览器解析HTML的一个过程。举个例子：<br>    在页面初始渲染的时候 ，一开始页面就是一个空白的页面，没有元素，后来我们添加新的元素使我们的页面布局发生了改变 这个过程就是回流与重绘。<br><em><strong>回流</strong></em>(Reflow)  就是引起Dom树结构变化，改变页面的 布局初始渲染阶段不可避免的就会发生回流<br><em><strong>重绘</strong></em> (Repaint)就是 我们在已经计算好位置大小的元素上给他进行样式的修改 ，他不会引起dom树的改变与页面格局的改变<br>    <strong>两者的联系</strong><br>    触发回流一定会触发重绘，触发重绘不一定会触发回流</p>
<h4 id="浏览器解析渲染机制"><a href="#浏览器解析渲染机制" class="headerlink" title="浏览器解析渲染机制"></a>浏览器解析渲染机制</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.vue-js.com/2b56a950-9cdc-11eb-ab90-d9ae814b240d.png" alt="解析渲染"></p>
<ol>
<li><p>解析HTML，生成DOM树，解析CSS，生成CSSOM树</p>
</li>
<li><p>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</p>
</li>
<li><p>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</p>
</li>
<li><p>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</p>
</li>
<li><p>Display:将像素发送给GPU，展示在页面上</p>
</li>
</ol>
<h2 id="二、什么时候触发"><a href="#二、什么时候触发" class="headerlink" title="二、什么时候触发"></a>二、什么时候触发</h2><h4 id="1-回流"><a href="#1-回流" class="headerlink" title="1. 回流"></a><strong>1. 回流</strong></h4><p>当Render Tree中部分或全部元素的尺寸,结构或者某些属性发生改变时,浏览器就重新渲染部分或全部文档<br>例如：</p>
<ul>
<li>添加或删除可见的DOM元素</li>
<li>元素的位置发生变化</li>
<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>
<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代</li>
<li>页面一开始渲染的时候（这避免不了）</li>
<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>
<li>激活 CSS 伪类，比如 :hover</li>
<li>操作class属性</li>
<li>计算offsetWidth和offsetHeight属性</li>
<li>设置 style 属性的值</li>
<li>获取一些特定的属性值<ul>
<li>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight<br>  -getComputedStyle方法 他跟上面的属性一样需要通过计算得到 ，浏览器为了获取这些值就会就行回流。</li>
</ul>
</li>
</ul>
<h4 id="1-重绘"><a href="#1-重绘" class="headerlink" title="1. 重绘"></a><strong>1. 重绘</strong></h4><p>处了触发回流就会触发重绘以外 </p>
<ul>
<li>修改颜色</li>
<li>修改阴影</li>
<li>修改文本方向<br>这些也会触发重绘</li>
</ul>
<h2 id="三、性能的影响"><a href="#三、性能的影响" class="headerlink" title="三、性能的影响"></a>三、性能的影响</h2><p>回流比重绘的代价要更高 可以说是牵一发 动全身 </p>
<p>现在我们的<strong>浏览器</strong>机制会对此进行<strong>优化</strong></p>
<p>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列</p>
<h2 id="四、如何避免回流与重绘"><a href="#四、如何避免回流与重绘" class="headerlink" title="四、如何避免回流与重绘"></a>四、如何避免回流与重绘</h2><p><em><strong>CSS:</strong></em></p>
<ol>
<li><p>避免使用table布局。table 中每个元素的大小以及内容的改动，都会导致整个 table 的重新计算</p>
</li>
<li><p>通过改变元素的class类名设置元素的样式，尽可能在DOM树的最末端改变class。</p>
</li>
<li><p>避免设置多层内联样式。</p>
</li>
<li><p>将动画效果应用到position属性为absolute或fixed的元素上。</p>
</li>
<li><p>避免使用CSS表达式（例如：calc()）。</p>
</li>
<li><p>对于那些复杂的动画，对其设置 position: fixed&#x2F;absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响</p>
</li>
<li><p>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘</p>
</li>
</ol>
<p><em><strong>JavaScript:</strong></em></p>
<ol>
<li><p>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</p>
</li>
<li><p>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</p>
</li>
<li><p>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</p>
</li>
<li><p>避免频繁读取会引发回流&#x2F;重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</p>
</li>
<li><p>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</p>
</li>
<li><p>避免改变样式，使用类名去合并样式</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>如何修改react项目端口号</title>
    <url>/2020/10/20/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9react%E9%A1%B9%E7%9B%AE%E7%AB%AF%E5%8F%A3%E5%8F%B7/</url>
    <content><![CDATA[<h4 id="我们一般react的默认端口号都是3000，当我们想要同时打开两个项目的时候他就会提示端口号占用，如何解决这个问题-，有两个办法："><a href="#我们一般react的默认端口号都是3000，当我们想要同时打开两个项目的时候他就会提示端口号占用，如何解决这个问题-，有两个办法：" class="headerlink" title="我们一般react的默认端口号都是3000，当我们想要同时打开两个项目的时候他就会提示端口号占用，如何解决这个问题 ，有两个办法："></a>我们一般react的默认端口号都是3000，当我们想要同时打开两个项目的时候他就会提示端口号占用，如何解决这个问题 ，有两个办法：</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>依次打开node_modules &#x3D;&gt; react-scripts &#x3D;&gt; scripts<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/0ef110829bc048ec887c803924fa556d.png" alt="在这里插入图片描述"><br>然后点击进入start.js 文件夹 下滑找到第55行左右<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/3a078a8fbd1c48c68fcccca73590c4b5.png" alt="在这里插入图片描述">直接修改3000改成你想要的端口号 重启项目就可以了 。</p>
<h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>这个方法就相对简单了  我们每次创建项目都会有一个package.json文件 ，这个文件是记录我们项目安装包的文件 </p>
<p>我们打开这个文件 </p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;react-scripts start&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;react-scripts build&quot;</span>,</span><br><span class="line">  <span class="string">&quot;test&quot;</span>: <span class="string">&quot;react-scripts test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;eject&quot;</span>: <span class="string">&quot;react-scripts eject&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p> 找到这段调试代码<br> 修改start 给他加上一个PORT值 如下图所示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;set PORT=8050 &amp;&amp; react-scripts start&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;react-scripts build&quot;</span>,</span><br><span class="line">  <span class="string">&quot;test&quot;</span>: <span class="string">&quot;react-scripts test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;eject&quot;</span>: <span class="string">&quot;react-scripts eject&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>最后重启项目 我们的端口号就被修改了</p>
]]></content>
  </entry>
  <entry>
    <title>深拷贝浅拷贝</title>
    <url>/2022/10/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1>]]></content>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2022/11/16/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1-说说你对盒子模型的理解"><a href="#1-说说你对盒子模型的理解" class="headerlink" title="1.说说你对盒子模型的理解"></a>1.说说你对盒子模型的理解</h2><p>当对一个文档进行布局的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型，将所有元素表示为一个个矩形的盒子 这个盒子就是盒模型 一个盒子由四个部分组成：content(实际内容) padding(内边距) border(边框) margin(外边距) 盒子模型可以分为W3C标准盒子模型 IE怪异盒子模型 标准盒子模型，是浏览器默认的盒子模型 width&#x2F;height 只是内容高度，不包含 padding 和 border值 怪异盒子模型 width&#x2F;height 包含了 padding和 border值</p>
<h2 id="2-css选择器有哪些？优先级？哪些属性可以继承？"><a href="#2-css选择器有哪些？优先级？哪些属性可以继承？" class="headerlink" title="2.css选择器有哪些？优先级？哪些属性可以继承？"></a>2.css选择器有哪些？优先级？哪些属性可以继承？</h2><p>Id选择器 类选择器 标签选择器 后代选择器 子选择器 相邻同胞选择器 群组选择器 伪类选择器 伪元素选择器 属性选择器<br>优先级：内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器<br>继承：文本系列属性 元素可见性 表格布局属性 列表属性 引用 光标属性font组合字体 text-indent text-align line-height visibility caption-side </p>
<h2 id="3-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"><a href="#3-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？" class="headerlink" title="3.元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"></a>3.元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</h2><p>定位+margin:auto：父级设置相对定位 子级绝对定位 如果子级没有宽高就会被拉开父级一样的宽高 如果设置了宽高 给他一个margin:auto就可以了<br>定位+margin:负值：设置父元素为相对定位， 子元素移动自身50%实现水平垂直居中<br>定位+transform：是margin负值的替代方案，并不需要知道自身元素的宽高<br>Table布局：设置父元素为display:table-cell，子元素设置 display: inline-block。利用vertical和text-align可以让所有的行内块级元素水平垂直居中<br>Flex弹性布局<br>Gird网格布局<br>不定宽高：定位+margin:auto 定位+transform</p>
<h2 id="4-怎么理解回流跟重绘？什么场景下会触发？"><a href="#4-怎么理解回流跟重绘？什么场景下会触发？" class="headerlink" title="4.怎么理解回流跟重绘？什么场景下会触发？"></a>4.怎么理解回流跟重绘？什么场景下会触发？</h2><p>回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置<br>重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制<br>回流场景：添加或删除可见的DOM元素 元素的位置发生变化 元素的尺寸发生变化 页面一开始渲染的时候 浏览器的窗口尺寸变化<br>重绘场景：触发回流一定会触发重绘 颜色的修改 文本方向的修改 阴影的修改</p>
<h2 id="5-什么是响应式设计？响应式设计的基本原理是什么？如何做？"><a href="#5-什么是响应式设计？响应式设计的基本原理是什么？如何做？" class="headerlink" title="5.什么是响应式设计？响应式设计的基本原理是什么？如何做？"></a>5.什么是响应式设计？响应式设计的基本原理是什么？如何做？</h2><p>响应式网站设计是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境进行相应的响应和调整<br>基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有meta声明viewport<br>媒体查询、百分比、vw&#x2F;vh、rem</p>
<h2 id="6-如果要做优化，CSS提高性能的方法有哪些？"><a href="#6-如果要做优化，CSS提高性能的方法有哪些？" class="headerlink" title="6.如果要做优化，CSS提高性能的方法有哪些？"></a>6.如果要做优化，CSS提高性能的方法有哪些？</h2><p>内联首屏关键CSS、异步加载CSS、资源压缩、合理使用选择器、减少使用昂贵的属性、不使用@import</p>
<h2 id="7-对前端工程师这个职位是怎么样理解的？它的前景会怎么样"><a href="#7-对前端工程师这个职位是怎么样理解的？它的前景会怎么样" class="headerlink" title="7.对前端工程师这个职位是怎么样理解的？它的前景会怎么样"></a>7.对前端工程师这个职位是怎么样理解的？它的前景会怎么样</h2><p>……</p>
<h2 id="8-说说JavaScript中的数据类型？存储上的差别？"><a href="#8-说说JavaScript中的数据类型？存储上的差别？" class="headerlink" title="8.说说JavaScript中的数据类型？存储上的差别？"></a>8.说说JavaScript中的数据类型？存储上的差别？</h2><p>分为基本类型和复杂类型<br>基本类型包含Number、String、Boolean、Undefined、null、symbol<br>复杂类型包含Object、Array、Function<br>声明变量时不同的内存地址分配：简单类型的值存放在栈中 存放的是对应的值、引用类型对应的值存储在堆中 在栈中存放的是指向堆内存的地址<br>不同的类型数据导致赋值变量时的不同：简单类型赋值，是生成相同的值，两个对象对应不同的地址、复杂类型赋值，是将保存对象的内存地址赋值给另一个变量</p>
<h2 id="9-typeof-与-instanceof-区别"><a href="#9-typeof-与-instanceof-区别" class="headerlink" title="9.typeof 与 instanceof 区别"></a>9.typeof 与 instanceof 区别</h2><p>typeof 是判断数据类型的一个方法 操作符返回一个字符串，表示未经计算的操作数的类型<br>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上<br>区别：typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值、instanceof可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型、而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断显示的都是object</p>
<h2 id="10-说说你对闭包的理解？闭包使用场景"><a href="#10-说说你对闭包的理解？闭包使用场景" class="headerlink" title="10.说说你对闭包的理解？闭包使用场景"></a>10.说说你对闭包的理解？闭包使用场景</h2><p>一个函数和对其周围状态的引用捆绑在一起或者说函数被引用包围，这样的组合就是闭包 闭包让你可以在一个内层函数中访问到其外层函数的作用域<br>使用场景：创建私有变量、延长变量的生命周期</p>
<h2 id="11-bind、call、apply-区别？如何实现一个bind"><a href="#11-bind、call、apply-区别？如何实现一个bind" class="headerlink" title="11.bind、call、apply 区别？如何实现一个bind?"></a>11.bind、call、apply 区别？如何实现一个bind?</h2><p>三者都可以改变函数的this对象指向<br>三者第一个参数都是this要指向的对象，如果没有这个参数或参数为undefined或null，则默认指向全局window<br>三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入<br>Bind是返回绑定this之后的函数，apply、call 则是立即执行<br> bind的三个特点 (1)保存this,返回新的函数 (2)可以传入参数 (3)一个绑定函数也可以使用new操作符创建对象</p>
<h2 id="12-说说你对事件循环的理解"><a href="#12-说说你对事件循环的理解" class="headerlink" title="12.说说你对事件循环的理解"></a>12.说说你对事件循环的理解</h2><p>同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行 上述过程的不断重复就事件循环<br>事件循环分为宏任务和微任务<br>微任务：一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前 常见的有：Promise.then MutationObserver process.nextTick<br>常见宏任务有：script setTimeout&#x2F;setInterval UI rendering postMessage MessageChannel setImmediate I&#x2F;O</p>
<p>前端开发中我们会通过 setTimeout&#x2F;setInterval 来指定定时务，会通过 XHR&#x2F;fetch 发送网络请求<br>。接下来简述一下 setTimeout&#x2F;setInterva1和 XHR&#x2F;fetch 到底做了什么事我们知道，不管是setTimeout&#x2F;setinterval 和 XHR&#x2F;fetch代码，在这些代码执行时，本身是同步任务，而其中的回调函数才是异步任务<br>当代码执行到 setTimeout&#x2F;setInterva1时，实际上是S引擎线程通知 定时触发器线程，间隔一个时间后，会触发一个回调事件<br>而定时触发器线程在接收到这个消息后，会在等待的时间后，将回调事件放入到由 事件触发线程所管理的事件队列中当代码执行到 XHR&#x2F;fetch 时，实际上是JS引擎线程通知 异步http 请求线程，发送一个网络请求，并制定请求完成后的回调事件<br>而异步http 请求线程在接收到这个消息后，会在请求成功后，将回调事件放入到由 事件触发线程所管理的 事件队列中当我们的同步任务执行完，，Js 引擎线程会询问事件触发线程，在 事件队列中是否有待执行的回调函数，如果有就会加入到执行栈中交给IS引擎线程执行<br>.<br>0<br>结<br>。IS引擎线程只执行执行栈中的事件<br>。执行栈中的代码执行完毕，就会读取事件队列中的事件.事件队列中的回调事件，是由各自线程插入到事件队列中的<br>。如此循环                                                                                             </p>
<h2 id="13-DOM常见的操作有哪些"><a href="#13-DOM常见的操作有哪些" class="headerlink" title="13.DOM常见的操作有哪些"></a>13.DOM常见的操作有哪些</h2><p>创建节点：createElement、createTextNode、createDocumentFragment、createAttribute<br>查询节点：querySelector、querySelectorAll<br>更新节点：innerHTML、innerText、textContent、style<br>添加节点：innerHTML、appendChild、insertBefore、setAttribute<br>删除节点：removeChild</p>
<h2 id="14-说说你对BOM的理解，常见的BOM对象你了解哪些？"><a href="#14-说说你对BOM的理解，常见的BOM对象你了解哪些？" class="headerlink" title="14.说说你对BOM的理解，常见的BOM对象你了解哪些？"></a>14.说说你对BOM的理解，常见的BOM对象你了解哪些？</h2><p>BOM是浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象 其作用就是跟浏览器做一些交互效果,比如如何进行页面的后退，前进，刷新，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息 Bom的核心对象是window，它表示浏览器的一个实例<br>常见的BOM对象：window、location、navigator、screen、history</p>
<h2 id="15-Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#15-Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="15.Javascript本地存储的方式有哪些？区别及应用场景？"></a>15.Javascript本地存储的方式有哪些？区别及应用场景？</h2><p>Cookie、sessionStorage、localStorage、indexedDB<br>区别：<br>存储大小：cookie数据大小不能超过4k，sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多<br>有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage数据在当前浏览器窗口关闭后自动删除；cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭<br>数据与服务器之间的交互方式：cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端； sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存<br>场景：<br>标记用户与跟踪用户行为的情况，推荐使用cookie<br>适合长期保存在本地的数据（令牌），推荐使用localStorage<br>敏感账号一次性登录，推荐使用sessionStorage<br>存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB</p>
<h2 id="16-什么是防抖和节流？有什么区别？如何实现？"><a href="#16-什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="16.什么是防抖和节流？有什么区别？如何实现？"></a>16.什么是防抖和节流？有什么区别？如何实现？</h2><p>防抖：n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时<br>节流：n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效<br>区别：<br>函数防抖在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能<br>函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次<br>实现：<br>节流：使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行；使用定时器写法，delay毫秒后第一次执行，第二次事件停止触发后依然会再一次执行；也可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流<br>防抖：使用一个变量来判断你的每次操作时候是否已经触发过定时器了，如果触发过了就将原来触发但还没到n秒的定时器清除，接着重新来个n秒的定时器；如果没触发过说明n秒内没有进行操作，新建一个n秒的定时器就行</p>
<h2 id="17-如何通过JS判断一个数组"><a href="#17-如何通过JS判断一个数组" class="headerlink" title="17.如何通过JS判断一个数组"></a>17.如何通过JS判断一个数组</h2><p>通过instanceof判断：instanceof运算符用于检验构造函数的prototype属性是否出现在对象的原型链中的任何位置，返回一个布尔值<br>通过constructor判断：实例的构造函数属性constructor指向构造函数，通过constructor属性可以判断是否为一个数组<br>通过Object.prototype.toString.call()判断：Object.prototype.toString.call()可以获取到对象的不同类型<br>通过Array.isArray()判断：Array.isArray()用于确定传递的值是否是一个数组，返回一个布尔值</p>
<h2 id="18-说说你对作用域链的理解"><a href="#18-说说你对作用域链的理解" class="headerlink" title="18.说说你对作用域链的理解"></a>18.说说你对作用域链的理解</h2><p>作用域 即变量和函数生效的区域或集合 换句话说 作用域决定了代码区块中变量和其他资源的可见性 作用域一般分为全局作用域、函数作用域、块级作用域<br>作用域链：当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域 这就是作用域链</p>
<h2 id="19-JavaScript原型，原型链-有什么特点？"><a href="#19-JavaScript原型，原型链-有什么特点？" class="headerlink" title="19.JavaScript原型，原型链 ? 有什么特点？"></a>19.JavaScript原型，原型链 ? 有什么特点？</h2><p>原型：JS中每个函数都存在有一个原型对象属性prototype。并且所有函数的默认原型都是Object的实例<br>原型链：每个继承父函数的子函数的对象都包含一个内部属性_proto_。该属性包含一个指针，指向父函数的prototype。若父函数的原型对象的_proto_属性为再上一层函数。在此过程中就形成了原型链。<br>特点：原型链实现了继承。原型链存在两个问题：包含引用类型值的原型属性会被所有实例共享；在创建子类型时，无法向超类型的构造函数中传递参数</p>
<h2 id="20-请解释什么是事件代理"><a href="#20-请解释什么是事件代理" class="headerlink" title="20.请解释什么是事件代理"></a>20.请解释什么是事件代理</h2><p>事件代理，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素 事件流的都会经过三个阶段： 捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段，而事件委托就是在冒泡阶段完成</p>
<h2 id="21-谈谈This对象的理解"><a href="#21-谈谈This对象的理解" class="headerlink" title="21.谈谈This对象的理解"></a>21.谈谈This对象的理解</h2><p>this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象 在绝大多数情况下，函数的调用方式决定了 this 的值 同时，this在函数执行过程中，this一旦被确定了，就不可以再更改<br>根据不同的场合 this有不同的值：默认绑定（严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象） 隐式绑定（函数可以作为某个对象的方法调用，这时this就指这个上级对象） new绑定（通过构建函数new关键字生成一个实例对象，此时this指向这个实例对象）</p>
<h2 id="22-new操作符具体干了什么"><a href="#22-new操作符具体干了什么" class="headerlink" title="22.new操作符具体干了什么"></a>22.new操作符具体干了什么</h2><p>在JavaScript中，new操作符用于创建一个给定构造函数的实例对象<br>new 通过构造函数创建出来的实例可以访问到构造函数中的属性<br>new 通过构造函数创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来）<br>创建一个新的对象<br>将构建函数中的this绑定到新建的对象上<br>根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理</p>
<p>new 经历了四个过程 </p>
<p>var fn &#x3D; function () f 1;var fnObj &#x3D; new fn();<br>1 创建了一个空对象<br>var obi &#x3D; new object();<br>2 设置 原型链Q2.<br>obj. proto  &#x3D; fn.prototype;<br>3、让fn的this指向obj，并执行fn的函数体<br>var result &#x3D; fn.call(obi);<br>4、判断fn的返回值类型，如果是值类型，返回obi。如果是引用类型，就返回这个引用类型的对象,<br>if (typeof(result) &#x3D;&#x3D; “object”)[fnObi &#x3D; result;l else !<br>fnobj &#x3D; obj;</p>
<p>}</p>
<h2 id="23-null，undefined-的区别"><a href="#23-null，undefined-的区别" class="headerlink" title="23.null，undefined 的区别"></a>23.null，undefined 的区别</h2><p>Null是空值 undefined是未定义的值<br>数据类型不同null的类型是object    undefined的类型是undefined<br>null和undefined两者相等，但是当两者做全等比较时，两者又不等<br>转化成数字 null是0 undefined是NaN<br>undefined是表示变量声明过但并未赋过值，它是所有未赋值变量默认值<br>null表示一个变量将来可能指向一个对象，一般用于主动释放指向对象的引用</p>
<h2 id="24-javascript-代码中的”use-strict”-是什么意思"><a href="#24-javascript-代码中的”use-strict”-是什么意思" class="headerlink" title="24.javascript 代码中的”use strict”;是什么意思"></a>24.javascript 代码中的”use strict”;是什么意思</h2><p>“use strict”;是一个字符串字面量，用来指定代码运行于严格模式下 严格模式下你不能使用未声明的变量 “严格模式”体现了Javascript更合理、更安全、更严谨的发展方向 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行</p>
<h2 id="25-同步和异步的区别"><a href="#25-同步和异步的区别" class="headerlink" title="25.同步和异步的区别"></a>25.同步和异步的区别</h2><p>同步：同步是指一个进程在执行某个请求的时候，如果该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去<br>异步：异步是指进程不需要一直等待下去，而是继续执行下面的操作，不管其他进程的状态，当有信息返回的时候会通知进程进行处理，这样就可以提高执行的效率了<br>如果是ajax去局部请求数据，也不一定都是适合使用异步的，比如应用程序往下执行时以来从服务器请求的数据，那么必须等这个数据返回才行，这时必须使用同步。而发送邮件的时候，采用异步发送就可以了，因为不论花了多长时间，对方能收到就好。总结得来说，就是看需要请求的数据是否是程序继续执行必须依赖的数据</p>
<h2 id="26-谈一谈箭头函数与普通函数的区别"><a href="#26-谈一谈箭头函数与普通函数的区别" class="headerlink" title="26.谈一谈箭头函数与普通函数的区别"></a>26.谈一谈箭头函数与普通函数的区别</h2><p>外形不同：箭头函数使用箭头定义，普通函数中没有。<br>箭头函数全都是匿名函数：普通函数可以有匿名函数，也可以有具名函数<br>箭头函数不能用于构造函数：普通函数可以用于构造函数，以此创建对象实例。<br>箭头函数中 this 的指向不同：在普通函数中，this 总是指向调用它的对象，如果用作构造函数，它指向创建的对象实例。<br>箭头函数不具有 arguments 对象：每一个普通函数调用后都具有一个arguments 对象，用来存储实际传递的参数。但是箭头函数并没有此对象。<br>其他区别：箭头函数不具有 prototype 原型对象。箭头函数不具有 super。<br>箭头函数不具有 new.target</p>
<h2 id="27-JS-数组和对象的遍历方式，以及几种方式的比较、"><a href="#27-JS-数组和对象的遍历方式，以及几种方式的比较、" class="headerlink" title="27.JS 数组和对象的遍历方式，以及几种方式的比较、"></a>27.JS 数组和对象的遍历方式，以及几种方式的比较、</h2><p>遍历数组方式：for in循环、for循环、forEach（forEach 无法遍历对象）、map、for of循环（ES6新增方法）<br>遍历对象：for…in…（遍历的是对象的键名）、Object.keys（会返回一个由一个指定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用for…in循环遍历该对象时返回的顺序一致）、Object.getOwnPropertyNames(obj)（返回一个数组，包含对象自身的所有属性（包含不可枚举属性） 结合forEach遍历可以获取key和value）<br>比较：<br>for…in 遍历（当前对象及其原型上的）每一个key,而 for…of遍历（当前对象上的）每一个value;<br>for in 以任意顺序遍历对象的可枚举属性（最好不要用来遍历数组）因此当迭代那些访问次序重要的 arrays 时用整数索引去进行 for 循环 (或者使用 Array.prototype.forEach() 或 for…of 循环)<br>for…of 允许遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等 但不能单独来遍历对象，要结合Object.keys一起使用才行</p>
<h2 id="28-如何解决跨域问题"><a href="#28-如何解决跨域问题" class="headerlink" title="28.如何解决跨域问题"></a>28.如何解决跨域问题</h2><p>跨域本质是浏览器基于同源策略的一种安全手段<br>同源策略是一种约定，它是浏览器最核心也最基本的安全功能 所谓同源（即指在同一个域）具有以下三个相同点：协议相同（protocol）、主机相同（host）、端口相同（port）反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域 一定要注意跨域是浏览器的限制<br>解决：JSONP(通过script标签)   、CORS（是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应 CORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允许的访问来源 只要后端实现了 CORS，就实现了跨域）、Proxy（Proxy也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接 在vue中使用时 我们可以在vue.config.js文件中新增proxy属性）</p>
<h2 id="29-XML和JSON的区别"><a href="#29-XML和JSON的区别" class="headerlink" title="29.XML和JSON的区别"></a>29.XML和JSON的区别</h2><p>xml：可扩展标记语言，是一种用于标记电子文件使其具有结构性的标记语言<br>json：(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式<br>区别：<br>它们都是一种数据交换格式<br>xml是重量级的，json是轻量级的<br>xml在传输过程中比较占带宽，json占带宽少，易于压缩<br>xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互<br>json可用jackson，gson等方法解析，xml可用dom，sax，demo4j等方式解析</p>
<h2 id="30-谈谈你对webpack的看法"><a href="#30-谈谈你对webpack的看法" class="headerlink" title="30.谈谈你对webpack的看法"></a>30.谈谈你对webpack的看法</h2><p>webpack 是一个用于现代JavaScript应用程序的静态模块打包工具 这里的静态模块指的是开发阶段，可以被 webpack 直接引用的资源 Webpack 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源<br>我们在开发过程中 可能会遇到需要通过模块化的方式来开发、使用一些高级的特性来加快我们的开发效率或者安全性、监听文件的变化来并且反映到浏览器上 提高开发效率等问题 webpack刚好就解决了这些问题</p>
<h2 id="31-webpack的打包原理"><a href="#31-webpack的打包原理" class="headerlink" title="31.webpack的打包原理"></a>31.webpack的打包原理</h2><p>webpack打包原理是将根据文件间的依赖关系对其进行静态分析，然后将这些模块按指定规则生成静态资源，当 webpack处理程序时，会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成bundle</p>
<h2 id="32-如何优化webpack打包速度"><a href="#32-如何优化webpack打包速度" class="headerlink" title="32.如何优化webpack打包速度"></a>32.如何优化webpack打包速度</h2><p>减小文件搜索范围；配置resolve.modules；设置test、include、exclude；增强代码压缩工具；用Happypack加速代码构建；拷贝静态文件</p>
<h2 id="33-说说webpack中常见的Loader？解决了什么问题？"><a href="#33-说说webpack中常见的Loader？解决了什么问题？" class="headerlink" title="33.说说webpack中常见的Loader？解决了什么问题？"></a>33.说说webpack中常见的Loader？解决了什么问题？</h2><p>Style-loader（将css添加到DOM的内联样式标签style里）、css-loader（允许将css文件通过require的方式引入，并返回css代码）、less-loader（ 处理less）、sass-loader（处理sass）、postcss-loader（用postcss来处理CSS）、file-loader（分发文件到output目录并返回相对路径）<br>Webpack仅仅是分析出各种模块的依赖关系 形成资源列表 最终打包生成指定的文件 默认情况下 在遇到import或require加载模块的时候 webpack只支持对js和json文件打包 像css、sass、less、png等文件 webpack无法进行解析 这时候就需要配置对应的loader进行文件内容的解析</p>
<h2 id="34-说说webpack中常见的Plugin？解决了什么问题？"><a href="#34-说说webpack中常见的Plugin？解决了什么问题？" class="headerlink" title="34.说说webpack中常见的Plugin？解决了什么问题？"></a>34.说说webpack中常见的Plugin？解决了什么问题？</h2><p>HtmlWebpackPlugin：简单创建html文件 用于服务器访问<br>AggressiveSplittingPlugin：将原来的chunk分成更小的chunk<br>BannerPlugin：在每个生成的chunk顶部添加banner<br>CommonsChunkPlugin：提取chunks之间共享的通用模块<br>DefinePlugin：允许在编译时配置的全局常量</p>
<h2 id="35-说说你对promise的了解"><a href="#35-说说你对promise的了解" class="headerlink" title="35.说说你对promise的了解"></a>35.说说你对promise的了解</h2><p><code>Promise</code>，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>链式操作减低了编码难度</li>
<li>代码可读性明显增强</li>
</ul>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p><code>promise</code>对象仅有三种状态</p>
<ul>
<li><code>pending</code>（进行中）</li>
<li><code>fulfilled</code>（已成功）</li>
<li><code>rejected</code>（已失败）</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li>
<li>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</li>
</ul>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例  接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code></p>
<ul>
<li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”</li>
<li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”</li>
</ul>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ul>
<li>then()<ul>
<li><code>then</code>方法返回的是一个新的<code>Promise</code>实例 ，是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</li>
</ul>
</li>
<li>catch()<ul>
<li>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数</li>
</ul>
</li>
<li>finally()<ul>
<li>不管 Promise 对象最后状态如何，都会执行的操作</li>
</ul>
</li>
</ul>
<h4 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h4><p><code>Promise</code>构造函数存在以下方法：</p>
<ul>
<li><p>all()</p>
<ul>
<li><p><code>Promise.all()</code>方法用于将多个 <code>Promise</code>实例，包装成一个新的 <code>Promise</code>实例</p>
</li>
<li><p>接受一个数组（迭代对象）作为参数，数组成员都应为<code>Promise</code>实例</p>
</li>
<li><p>实例<code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分为两种：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<ul>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</li>
<li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数</li>
</ul>
</li>
</ul>
</li>
<li><p>race()</p>
<ul>
<li>接收一个数组（迭代对象）作为参数，只要有一个实例率先改变状态，总的状态就跟着改变</li>
<li>率先改变的 Promise 实例的返回值则传递给<code>p</code>的回调函数</li>
</ul>
</li>
<li><p>allSettled()</p>
<ul>
<li><p>接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</p>
<p>只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束</p>
</li>
</ul>
</li>
<li><p>resolve()</p>
<ul>
<li>将现有对象转为 <code>Promise</code>对象</li>
<li>参数可以分成四种情况，分别如下：<ul>
<li>参数是一个 Promise 实例，<code>promise.resolve</code>将不做任何修改、原封不动地返回这个实例</li>
<li>参数是一个<code>thenable</code>对象，<code>promise.resolve</code>会将这个对象转为 <code>Promise</code>对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法</li>
<li>参数不是具有<code>then()</code>方法的对象，或根本就不是对象，<code>Promise.resolve()</code>会返回一个新的 Promise 对象，状态为<code>resolved</code></li>
<li>没有参数时，直接返回一个<code>resolved</code>状态的 Promise 对象</li>
</ul>
</li>
</ul>
</li>
<li><p>reject()</p>
<ul>
<li>返回一个新的 Promise 实例，该实例的状态为<code>rejected</code></li>
<li><code>Promise.reject()</code>方法的参数，会原封不动地变成后续方法的参数</li>
</ul>
</li>
<li><p>try()</p>
</li>
</ul>
<h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><ol>
<li>将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化</li>
<li>通过<code>all()</code>实现多个请求合并在一起，汇总所有请求结果，只需设置一个<code>loading</code>即可</li>
<li>通过<code>race</code>可以设置图片请求超时</li>
</ol>
<h2 id="36-async函数是什么，有什么作用"><a href="#36-async函数是什么，有什么作用" class="headerlink" title="36.async函数是什么，有什么作用"></a>36.async函数是什么，有什么作用</h2><p>(1)Async 函数是Generator函数的语法糖， 特点如下：	<br>①语义化更好，await 一看就知道在等待后面的操作完成<br>②实用性更广 Generator函数后面只能跟thunk函数或者promise对象，但是await就不一样了 也可以跟同步代码<br>③Generator返回的是迭代对象，而async返回的是promise对象<br>(2)Async 函数有什么作用;<br>①Async 和 await 从字面意思上很好理解，async是异步的意思，await有等待的意思，而两者的用法也是如此，async用于声明一个function是异步的，而await用于等待一个异步方法完成</p>
<h2 id="37-有使用过vue吗？说说你对vue的理解"><a href="#37-有使用过vue吗？说说你对vue的理解" class="headerlink" title="37.有使用过vue吗？说说你对vue的理解"></a>37.有使用过vue吗？说说你对vue的理解</h2><p>(1)Vue是一个用于创建用户界面的开源的JavaScript框架，也是一个创建单页应用的web应用框架<br>(2)Vue的核心特性是 数据驱动（MVVM）<br>①MVVM 表示的是Model -View -ViewModel<br>1)Model :模型层，负责处理业务逻辑以及和服务器端进行交互<br>2)View 视图层，负责将数据模型转化为UI展示出来，还可以简单的理解为HTML页面<br>3)ViewModel 视图模型层，用来连接Model和View 是Model和View之间的通信桥梁<br>②组件化：<br>1)一句话来说就是把图形 非图形的各种逻辑均抽象成为一个统一的概念来实现开发的模式<br>2)组件化可以降低整个系统的耦合度，提高开发效率  便于调试 提高了代码的可维护性<br>③指令系统：<br>1)指令是带有V-前缀的特殊属性作用，当表达式的值改变时，将其产生的连带影响，响应式的作用于DOM<br>2)常用的指令有： V-if v-model  v-bind  v-on v-model<br>④Vue所有的界面事件 都只是去操作数据的，Jquery操作 Vue所有界面的改动，都是根据数据自动绑定出来的，Jquery操作DOM<br>⑤Vue和React的对比:<br>1)都有组件化思想，都支持服务器渲染 ，都有虚拟DOM  数据驱动视图，都支持native的方案，都有自己的构建工具<br>2)数据流向不同， react单向数据流， vue双向数据流，<br>3)数据变化的实现原理不同，React使用不可变数据，vue使用可变数据<br>4)组件化通信的不同 react中使用回调函数来进行通信， vue中子组件向父组件传递消息的方式有两种，事件和回调函数<br>5)Diff算法不同，react主要使用diff队列保存需要更新哪些DOM 得到patch树，在统一的操作批量更新DOM  Vue使用双向指针，边对比，边更新DOM</p>
<h2 id="38-你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"><a href="#38-你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢" class="headerlink" title="38.你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"></a>38.你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢</h2><p>(1)什么是SPA：<br>①Spa 翻译过来就是单页应用spa是一种网络程序或者网站的模型，她通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用之中，所有必要的代码都通过单个页面的加载而进行检索，或者根据需要 动态装载适当的资源并添加到页面，页面在任何时间点都不会重新加载，也不讲控制转移到其它页面<br>(2)优缺点：<br>①优点：<br>1)具有桌面应用的即时性，网站的可移植性和可访问性<br>2)用户体验好，快，内容的改变不需要重新加载整个页面<br>3)良好的前后端分离，分工更明确<br>②缺点：<br>1)不利于搜索引擎的抓取<br>2)首次渲染速度相对较慢<br>(3)实现一个spa<br>①原理<br>1)监听地址栏中hash变化驱动界面变化<br>2)用pushsate记录浏览器的历史，驱动界面发送变化<br>②实现：<br>1)Hash模式 核心通过监听url中的hash来进行路由跳转<br>history模式<br>history 模式核心借用 HTML5 history api，api 提供了丰富的 router 相关属性先了解一个几个相关的api</p>
<p>history.pushState 浏览器历史纪录添加记录<br>history.replaceState修改浏览器历史纪录中当前纪录<br>history.popState 当 history 发生变化时触发</p>
<h2 id="39-SPA首屏加载速度慢的怎么解决？"><a href="#39-SPA首屏加载速度慢的怎么解决？" class="headerlink" title="39.SPA首屏加载速度慢的怎么解决？"></a>39.SPA首屏加载速度慢的怎么解决？</h2><p>什么是首屏加载：<br>首屏时间 指的是浏览器从响应用户输入网址地址，到首屏呢容渲染完成的时间，此时整个网页不一定要全部渲染完成，但是需要展示当前视窗需要的内容 首屏加载可以说是用户体验中最重要的环节</p>
<p>加载慢的原因：<br>网络延时问题<br>资源文件体积是否过大<br>资源是否重复发送请求去加载了<br>加载脚本的时候，渲染内容堵塞了</p>
<p>解决方法：<br>减少入口文件体积<br>静态资源本地保存<br>UI框架按需加载<br>图片资源的压缩<br>组件重复打包<br>开启GZIP压缩<br>使用SSR</p>
<h2 id="40-VUE路由的原理"><a href="#40-VUE路由的原理" class="headerlink" title="40.VUE路由的原理"></a>40.VUE路由的原理</h2><p>实现一个静态Install方法，因为作为插件都必须有这个方法，给Vue.use去调用<br>可以监听路由变化<br>解析配置的路由，及解析router的配置项routes 能根据路由匹配到对应组件<br>实现两个全局组件的router-link  和router-view （最终落地点）</p>
<h2 id="41-Vue中组件和插件有什么区别？"><a href="#41-Vue中组件和插件有什么区别？" class="headerlink" title="41.Vue中组件和插件有什么区别？"></a>41.Vue中组件和插件有什么区别？</h2><p>组件：把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件、<br>优势：降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求；调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题；提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级<br>插件：常用来为 Vue 添加全局功能 功能范围：添加全局方法或者属性；添加全局资源；通过全局混入来添加一些组件选项；添加Vue实例方法，通过把它们添加到Vue.prototype上实现；一个库，提供自己的API，同时提供上面提到的一个或多个功能<br>区别：<br>编写形式：组件（编写一个组件，可以有很多方式，我们最常见的就是vue单文件的这种格式，每一个.vue文件我们都可以看成是一个组件 还可以通过template属性来编写一个组件，如果组件内容多，我们可以在外部定义template组件内容，如果组件内容并不多，我们可直接写在template属性上）插件（vue插件的实现应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象）<br>注册形式：组件（vue组件注册主要分为全局注册与局部注册 全局注册通过Vue.component方法，第一个参数为组件的名称，第二个参数为传入的配置项 局部注册只需在用到的地方通过components属性注册一个组件）</p>
<p>插件（插件的注册通过Vue.use()的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项 注册插件的时候，需要在调用 new Vue() 启动应用之前完成 Vue.use会自动阻止多次注册相同插件，只会注册一次）<br>使用场景：组件（用来构成你的 App 的业务模块，它的目标是 App.vue）插件（用来增强你的技术栈的功能模块，它的目标是 Vue 本身 用来增强你的技术栈的功能模块，它的目标是 Vue 本身）</p>
<h2 id="42-Vue组件之间的通信方式都有哪些"><a href="#42-Vue组件之间的通信方式都有哪些" class="headerlink" title="42.Vue组件之间的通信方式都有哪些"></a>42.Vue组件之间的通信方式都有哪些</h2><p>分类：父子组件间的通信、兄弟组件间的通信、祖孙与后代组件之间的通信、非关系组件间之间的通信<br>方式：<br>Props：适用于父组件传递数据给子组件 子组件设置props属性 定义接收父组件传递过来的参数 父组件在使用子组件标签中通过字面量来传递值<br>$emit触发自定义事件：适用于子组件传递数据给父组件 子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值 父组件绑定监听器获取到子组件传递过来的参数<br>Ref：父组件在使用子组件的时候设置ref 父组件通过设置子组件ref来获取数据（this.$ref.foo）<br>EventBus：适用于兄弟组件传值 创建一个中央事件总线EventBus 兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值 另一个兄弟组件通过$on监听自定义事件<br>$parent或$root：通过共同祖辈$parent或者$root搭建通信桥连接<br>$attr与$listeners：适用于祖先传递数据给子孙 设置批量向下传属性$attrs和$listeners 包含了父级作用域中不作为prop被识别且获取的特性绑定 可以通过v-bind&#x3D;”$attrs”传入内部组件<br>Procide与inject：在祖先组件定义provide属性 返回传递的值；在后代组件通过inject接收组件传递过来的值<br>Vuex：适用于复杂关系的组件数据传递</p>
<h2 id="43-你了解vue的diff算法吗？说说看"><a href="#43-你了解vue的diff算法吗？说说看" class="headerlink" title="43.你了解vue的diff算法吗？说说看"></a>43.你了解vue的diff算法吗？说说看</h2><p>diff 算法是一种通过同层的树节点进行比较的高效算法 它有两个特点：比较只会在同层级进行, 不会跨层级比较；在diff比较的过程中，循环从两边向中间比较<br>diff 算法在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较<br>diff整体策略为：深度优先，同层比较<br>原理：当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图</p>
<h2 id="44-为什么需要-Virtual-Dom"><a href="#44-为什么需要-Virtual-Dom" class="headerlink" title="44.为什么需要 Virtual Dom"></a>44.为什么需要 Virtual Dom</h2><p>Virtual Dom也就是虚拟Dom 实际上它只是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上<br>在Javascript对象中，虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的名命可能会有差别<br>创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应<br>需要：DOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的 真实的DOM节点，哪怕一个最简单的div也包含着很多属性 DOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的真实的DOM节点，哪怕一个最简单的div也包含着很多属性 操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验<br>虚拟dom比真实dom体积小,操作是相对来说消耗性能少,如果在页面中删除一个dom,会引起重绘,影响后边元素的布局 虚拟dom不会进行回流和重绘操作 虚拟dom进行频繁的修改,然后一次性比较并修改真实DOM中需要改的部分,最后并在真实DOM中进行回流和重绘,减少过多DOM节点的回流和重绘<br>虚拟dom可能跨端(在服务器端也可以使用vue技术),跨平台</p>
<h2 id="45-Vue3-0的设计目标是什么？做了哪些优化"><a href="#45-Vue3-0的设计目标是什么？做了哪些优化" class="headerlink" title="45.Vue3.0的设计目标是什么？做了哪些优化"></a>45.Vue3.0的设计目标是什么？做了哪些优化</h2><p>设计目标：更小（Vue3移除一些不常用的 API 引入tree-shaking，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了）、更快（diff算法优化；静态提升；事件监听缓存；SSR优化）、typescript支持、API设计一致性、提高自身可维护性、开放更多底层功能<br>优化：源码（源码管理：vue3整个源码是通过 monorepo的方式维护的，根据功能将不同的模块拆分到packages目录下面不同的子目录中 Vue3是基于typeScript编写的，提供了更好的类型检查，能支持复杂的类型推导）、性能（体积优化、编译优化、数据劫持优化（vue3通过proxy监听整个对象））、语法API（优化逻辑组织：相同功能的代码编写在一块，而不像options API那样，各个功能的代码混成一块、优化逻辑复用：通过composition这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可）</p>
<h2 id="46-Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#46-Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="46.Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>46.Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h2><p>OptionsApi 是什么？<br>Options API，即大家常说的选项API，即以vue为后缀的文件，通过定义methods，computed，watch，data等属性与方法，共同处理页面逻辑</p>
<p>CompositionAPI是什么？<br>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p>
<p>在逻辑组织和逻辑复用方面，Composition API是优于Options API<br>因为Composition API几乎是函数，会有更好的类型推断。<br>Composition API对 tree-shaking 友好，代码也更容易压缩<br>Composition API中见不到this的使用，减少了this指向不明的情况<br>如果是小型组件，可以继续使用Options API，也是十分友好的</p>
<h2 id="47-说一下Vue数据响应式的原理"><a href="#47-说一下Vue数据响应式的原理" class="headerlink" title="47.说一下Vue数据响应式的原理"></a>47.说一下Vue数据响应式的原理</h2><p>响应式”，是指当数据改变后，Vue 会通知到使用该数据的代码。例如，视图渲染中使用了数据，数据改变后，视图也会自动更新。简而言之就是数据变页面变</p>
<p>实现原理：Vue在组件和实例初始化的时候，会将data里的数据进行数据劫持(object.definepropty对数据做处理)。被解除过后的数据会有两个属性：一个叫getter，一个叫setter。</p>
<p>getter是使用数据的时候触发，setter是在修改数据的时候触发，修改数据的时候触发setter，同时也触发了底层的watcher监听，通知dom修改刷新</p>
<p>Vue中数据变页面一定变嘛？、</p>
<p>那么问题来了，数据变页面一定变么？<br>不一定，数据变页面变的原因是因为数据劫持了data</p>
<h2 id="48-说说对-React-的理解？有哪些特性？"><a href="#48-说说对-React-的理解？有哪些特性？" class="headerlink" title="48.说说对 React 的理解？有哪些特性？"></a>48.说说对 React 的理解？有哪些特性？</h2><p>React，用于构建用户界面的 JavaScript 库，只提供了 UI 层面的解决方案<br>遵循组件设计模式、声明式编程范式和函数式编程概念，以使前端应用程序更高效<br>使用虚拟 DOM 来有效地操作 DOM，遵循从高阶组件到低阶组件的单向数据流<br>帮助我们将界面成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，构成整体页面<br>react 类组件使用一个名为 render() 的方法或者函数组件return，接收输入的数据并返回需要展示的内容<br>React 特性有很多，如：<br>JSX 语法<br>单向数据绑定<br>虚拟 DOM<br>声明式编程<br>Component<br>React 存在的优势：<br>高效灵活<br>声明式的设计，简单使用<br>组件式开发，提高代码复用率<br>单向响应的数据流会比双向绑定的更安全，速度更快</p>
<h2 id="49-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？"><a href="#49-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？" class="headerlink" title="49.说说 Real DOM 和 Virtual DOM 的区别？优缺点？"></a>49.说说 Real DOM 和 Virtual DOM 的区别？优缺点？</h2><p>两者的区别如下：<br>虚拟 DOM 不会进行排版与重绘操作，而真实 DOM 会频繁重排与重绘<br>虚拟 DOM 的总损耗是“虚拟 DOM 增删改+真实 DOM 差异增删改+排版与重绘”，真实 DOM 的总损耗是“真实 DOM 完全增删改+排版与重绘”<br>真实 DOM 的优势：<br>易用<br>缺点：<br>效率低，解析速度慢，内存占用量过高<br>性能差：频繁操作真实 DOM，易于导致重绘与回流<br>使用虚拟 DOM 的优势如下：<br>简单方便：如果使用手动操作真实 DOM 来完成页面，繁琐又容易出错，在大规模应用下维护起来也很困难<br>性能方面：使用 Virtual DOM，能够有效避免真实 DOM 数频繁更新，减少多次引起重绘与回流，提高性能<br>跨平台：React 借助虚拟 DOM，带来了跨平台的能力，一套代码多端运行<br>缺点：<br>在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化<br>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，速度比正常稍慢</p>
<h2 id="50-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？"><a href="#50-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？" class="headerlink" title="50.说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？"></a>50.说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？</h2><p>Mounting(挂载阶段)：已插入真实 DOM<br>Updating(更新阶段)：正在被重新渲染<br>Unmounting(卸载阶段)：已移出真实 DOM</p>
<p>挂载阶段:</p>
<ul>
<li>constructor() 在 React 组件挂载之前，会调用它的构造函数。</li>
<li>componentWillMount: 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。</li>
<li>componentDidMount(): 在组件挂载后（插入 DOM 树中）立即调用</li>
</ul>
<p>更新运行阶段:</p>
<ul>
<li>componentWillReceiveProps: 在接受父组件改变后的props需要重新渲染组件时用到的比较多，外部组件传递频繁的时候会导致效率比较低</li>
<li>shouldComponentUpdate():用于控制组件重新渲染的生命周期，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新</li>
<li>render(): render() 方法是 class 组件中唯一必须实现的方法。</li>
<li>componentWillUpdate(): shouldComponentUpdate返回true以后，组件进入重新渲染完成之前进入这个函数。</li>
<li>componentDidUpdate(): 每次state改变并重新渲染页面后都会进入这个生命周期<br>卸载或销毁阶段<br>componentWillUnmount ()： 在此处完成组件的卸载和数据的销毁。</li>
</ul>
<h2 id="51-说说-React中的setState执行机制"><a href="#51-说说-React中的setState执行机制" class="headerlink" title="51.说说 React中的setState执行机制"></a>51.说说 React中的setState执行机制</h2><p>React并不像vue2中调用Object.defineProperty数据响应式或者Vue3调用Proxy监听数据的变化</p>
<p>必须通过setState方法来告知react组件state已经发生了改变</p>
<p>通过触发事件，执行<code>this.setState</code>方法更新<code>state</code>状态，然后重新执行<code>render</code>函数，从而导致页面的视图更新</p>
<p>如果直接修改<code>state</code>的状态</p>
<p>使用setState更新数据的时候，setState的更新类型分成：</p>
<p>异步更新<br>同步更新</p>
<p>异步:<br>在使用setstate更新数据的时候，并不能在执行完setState之后立马拿到最新的state的结果</p>
<p>如果想要立刻获取更新后的值，在第二个参数的回调中更新后会执行</p>
<p>在组件生命周期或React合成事件中，setState是异步<br>在setTimeout或者原生dom事件中，setState是同步</p>
<p>在批量更新的时候  对同一个值进行多次 setState， setState 的批量更新策略会对其进行覆盖，取最后一次的执行结果<br>如果是下一个state依赖前一个state的话，推荐给setState一个参数传入一个function<br>而在setTimeout或者原生dom事件中，由于是同步的操作，所以并不会进行覆盖现象</p>
<h2 id="52-说说对React中类组件和函数组件的理解？有什么区别？"><a href="#52-说说对React中类组件和函数组件的理解？有什么区别？" class="headerlink" title="52.说说对React中类组件和函数组件的理解？有什么区别？"></a>52.说说对React中类组件和函数组件的理解？有什么区别？</h2><p>class组件是有状态的组件，可以定义state状态，函数组件无状态<br>class组件有生命周期的，函数组件无生命周期<br>class组件是由this对象，函数组件没有this对象<br>组件调用： class组件实例化后调用render方法调用，函数组件直接调用的。<br>class组件内部的话，render方法return返回渲染jsx模板，函数组件直接返回即可<br>ref获取子组件的对象，class组件可以直接获取到的，函数组件无法直接获取到。<br>绑定bind改变this指向，只适用于class组件</p>
<h2 id="53-说说对React-Hooks的理解？解决了什么问题？"><a href="#53-说说对React-Hooks的理解？解决了什么问题？" class="headerlink" title="53.说说对React Hooks的理解？解决了什么问题？"></a>53.说说对React Hooks的理解？解决了什么问题？</h2><p>useState</p>
<p>useState()用于为函数组件引入状态。在useState()中，数组第一项为一个变量，指向状态的当前值。类似this.state,第二项是一个函数，用来更新状态,类似setState</p>
<p>useEffect</p>
<p>useEffect()接受两个参数，第一个参数是你要进行的异步操作，第二个参数是一个数组，用来给出Effect的依赖项。只要这个数组发生变化，useEffect()就会执行</p>
<p>useRef</p>
<p>相当于class组件中的createRef的作用，ref.current获取绑定的对象</p>
<p>useContext</p>
<p>接受context状态树传递的数据内容</p>
<p>useReducer</p>
<p>接受reducer函数和状态的初始值作为参数，返回一个数组，其中第一项为当前的状态值，第二项为发送action的dispatch函数</p>
<p>userMemo useCallback</p>
<p>useMemo 和 useCallback接收的参数都是一样,第一个参数为回调，第二个参数为要依赖的数据<br>共同作用：仅仅依赖数据发生变化, 才会调用，也就是起到缓存的作用。useCallback缓存函数，useMemo 缓存返回值。</p>
<h2 id="54-说说你对Redux的理解？其工作原理？"><a href="#54-说说你对Redux的理解？其工作原理？" class="headerlink" title="54.说说你对Redux的理解？其工作原理？"></a>54.说说你对Redux的理解？其工作原理？</h2><p>在react中每个组件的state是由自身进行管理，包括组件定义自身的state、组件之间的通信通过props传递、使用Context实现数据共享等，如果让每个组件都存储自身相关的状态，理论上来讲不会影响应用的运行，但在开发及后期我们将比较难以维护，所以我们可以把数据进行集中式的管理，redux就是一个实现上述集中管理的容器的工具，redux并不是只应用在react中，还与其他界面库一起使用，如Vue</p>
<p>三大原则<br>state数据必须是单一数据源<br>redux中的state数据必须 是只读的，只能通过dispatch调用actions修改<br>Reducer必须使用纯函数来执行修改</p>
<p>React的组件需要获取或者修改页面的数据，通过dispatch方法调用actions进入到Reducer函数中修改state的数据内容，state更新后，通知组件更新页面即可。</p>
<p>redux的使用步骤<br>创建一个store文件夹，新建一个index.js文件<br>文件中导入redux的createStore方法，用于创建公共数据区域<br>创建一个reducer纯函数，接受两个参数state，actions分别表示分别表示数据和操作state的方法，返回state数据给组件页面<br>把reducer作为createStore的参数抛出<br>在需要使用的页面导入store文件，通过store.getState获取数据，通过store.dispatch触发action修改state数据<br>store.subscrible 方法监听 store 的改变，避免数据不更新</p>
<h2 id="55-说说-React-性能优化的手段有哪些"><a href="#55-说说-React-性能优化的手段有哪些" class="headerlink" title="55.说说 React 性能优化的手段有哪些"></a>55.说说 React 性能优化的手段有哪些</h2><p>1、前端通用优化。这类优化在所有前端框架中都存在，重点就在于如何将这些技巧应用在React组件中。<br>懒加载，在SPA中，懒加载优化一般用于从一个路由跳转到另一个路由。还可用于用户操作后才展示的复杂组件，比如点击按钮后展示的弹窗模块。<br>按优先级更新，及时响应用户，其思想是优先响应用户行为，在完成耗时操作。<br>缓存优化，缓存优化往往是最简单有效的优化方式，在React组件中常用到useMemo缓存上次计算的结果。当useMemo的依赖未发生变化时，就不会触发重新计算。<br>2、减少不必要的组件更新，这类优化是在组件状态发生变更后，通过减少不必要的组件更新来实现，对应到React中就是：减少渲染的节点、降低组件渲染的复杂度、充分利用缓存避免重新渲染。<br>如果是类组件，可以使用shouldComponentUpdate生命周期函数，可以在重新渲染组件时触发，可以利用此事件来决定何时重新渲染组件。<br>不要使用内联函数定义，会导致每次调用render函数时都会创建一个新的函数实例。<br>不要再render方法中导出数据。<br>在函数组件中使用useCallback和useMemo来进行组件优化，依赖没有变化的话，不重复执行。</p>
<h2 id="56-vue、react、angular-区别"><a href="#56-vue、react、angular-区别" class="headerlink" title="56.vue、react、angular 区别"></a>56.vue、react、angular 区别</h2><ol>
<li>基本概念</li>
</ol>
<p>Angular 是一个应用设计框架与开发平台，用于创建高效、复杂、精致的单页面应用。</p>
<p>React 是一个用于构建用户界面的 JavaScript 库</p>
<p>Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。<br>2. 三者比较<br>2.1 相同点</p>
<ol>
<li><p>都是基于javascript&#x2F;typescript的前端开发库，为前端开发提供高效、复用性高的开发方式</p>
</li>
<li><p>都有组件和模板的开发思想</p>
</li>
<li><p>各自的组件都有生命周期，不用的组件可以卸载，不占用资源</p>
</li>
<li><p>都支持指令，如样式、事件等的指令<br>2.2 不同点</p>
</li>
<li><p>创始和发行不同：</p>
<pre><code>Angular是由googl提供支持的，初始发行于 2016年9月；React由Facebook维护，初始发行于 2013年3月；Vue是由前google人员创建，初始发行于2014年2月
</code></pre>
</li>
<li><p>应用类型不同：</p>
<pre><code>Angular支持开发native应用程序、SPA单页应用程序、混合应用程序和web应用程序；React支持开发SPA和移动应用程序；Vue支持开发高级SPA，开始支持native应用程序
</code></pre>
</li>
<li><p>模型不同</p>
<pre><code>angular基于MVC（模型-视图-控制器）架构；react和vue是基于Virtual DOM（虚拟的文档对象模型）
</code></pre>
</li>
<li><p>数据流流向不同</p>
<p>  Angular使用的是双向数据绑定，React用的是单数据流的，而Vue则支持两者。</p>
</li>
<li><p>对微应用和微服务的支持不同</p>
<pre><code> Angular使用的是TypeScript，因此它更适合于单页Web应用（single page web application，SPA），而非微服务。相反，React和Vue的灵活性更适合微应用和微服务的开发。
</code></pre>
</li>
<li><p>对原生应用的支持不同</p>
<pre><code> React Native为iOS和Android开发原生应用；Angular的NativeScript已被原生应用所采用，特别是Ionic框架已经被广泛地运用在制作混合应用等方面；Vue的Weex平台正在开发之中，尚无下一步使之成为全面跨平台的计划。
</code></pre>
</li>
<li><p>框架和库</p>
<pre><code> Angular 是一个框架而不是一个库，因为它提供了关于如何构建应用程序的强有力的约束，并且还提供了更多开箱即用的功能。React 和 Vue 是是一种库，可以和各种包搭配。
</code></pre>
</li>
<li><p>组件之间传值方式不同</p>
<p> Angular 中直接的父子组件，父组件可以直接访问子组件的 public 属性和方法，也可以借助于@Input 和 @Output 进行通讯。没有直接关系的，借助于 Service 单例进行通讯；React 组件之间通过通过prop或者state来通信，不同组件之间还有Rex状态管理功能；Vue组件之间通信通过props ，以及Vuex状态管理来传值</p>
</li>
</ol>
<h2 id="57-说说你对-TypeScript-的理解？与-JavaScript-的区别"><a href="#57-说说你对-TypeScript-的理解？与-JavaScript-的区别" class="headerlink" title="57.说说你对 TypeScript 的理解？与 JavaScript 的区别"></a>57.说说你对 TypeScript 的理解？与 JavaScript 的区别</h2><p>TypeScript 是 Microsoft 开发和维护的一种面向对象的编程语言。它是 JavaScript 的超集，包含了 JavaScript 的所有元素，可以载入 JavaScript 代码运行，并扩展了 JavaScript 的语法。<br>TypeScript 具有以下特点：</p>
<pre><code>TypeScript 增加了静态类型、类、模块、接口和类型注解

TypeScript 可用于开发大型的应用
</code></pre>
<p>JavaScript 和 TypeScript 的主要差异</p>
<pre><code>TypeScript 从核心语言方面和类概念的模塑方面对 JavaScript 对象模型进行扩展。

JavaScript 代码可以在无需任何修改的情况下与 TypeScript 一同工作，同时可以使用编译器将 TypeScript 代码转换为 JavaScript。

TypeScript 通过类型注解提供编译时的静态类型检查。

TypeScript 中的数据要求带有明确的类型，JavaScript不要求。

TypeScript 为函数提供了缺省参数值。

TypeScript 引入了 JavaScript 中没有的“类”概念。

TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。
</code></pre>
<h2 id="58-说说你对-TypeScript-中泛型的理解？应用场景？"><a href="#58-说说你对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="58.说说你对 TypeScript 中泛型的理解？应用场景？"></a>58.说说你对 TypeScript 中泛型的理解？应用场景？</h2><p>泛型程序设计（generic programming）是程序设计语言的一种风格或范式</p>
<p>泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型 在typescript中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性<br>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。<br>在编写 typescript 的时候，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性的时候，这种情况下就可以使用泛型</p>
<h2 id="59-说说你对微信小程序的理解？优缺点？"><a href="#59-说说你对微信小程序的理解？优缺点？" class="headerlink" title="59.说说你对微信小程序的理解？优缺点？"></a>59.说说你对微信小程序的理解？优缺点？</h2><p>小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用</p>
<p>也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载<br>优点：<br>1、对用户使用上来说，确实方便，要用的时候打开，不用的时候关掉，即用即走。这点比需要下载，还要占用手机内存空间的APP要好。<br>2、主要的样式代码都封装在微信小程序里面，所以打开速度比普通的H5要快，接近原生APP。<br>3、可以调用比H5更多的手机系统功能来进行开发，例如GPS定位、录音、拍视频、重力感应等，能开发更丰富的使用场景。<br>4、在安卓手机上可以添加到手机桌面，看上去跟原生APP差不多，但仅限安卓手机，iphone就不行了。<br>5、运行速度跟APP差不多，也能做出很多H5不做到的功能，开发成本跟H5差不多，相对来说开发成本比APP要低。<br>缺点：<br>1、微信小程序只有1M的大小，这样导致无法开发大型一些的小程序。所以目前你会看到很多小程序真的很小很简单。<br>2、小程序的技术框架还不稳定，开发方法时常有修改，导致短时间内经常要升级维护。<br>3、不能跳转外链网址，所以间接影响了小程序的开放性。<br>4、不能直接分享到朋友圈，哎呀，少了一个重要的推广方式。<br>5、需要像APP一样审核上架，这点比HTML5即做即发布要麻烦些。</p>
<h2 id="60-说说你对发布订阅、观察者模式的理解？区别？"><a href="#60-说说你对发布订阅、观察者模式的理解？区别？" class="headerlink" title="60.说说你对发布订阅、观察者模式的理解？区别？"></a>60.说说你对发布订阅、观察者模式的理解？区别？</h2><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新</p>
<p>观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯</p>
<p>发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在</p>
<p>同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在</p>
<p>区别：<br>在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</p>
<p>在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。</p>
<p>观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）</p>
<h2 id="61-项目做过哪些性能优化"><a href="#61-项目做过哪些性能优化" class="headerlink" title="61.项目做过哪些性能优化"></a>61.项目做过哪些性能优化</h2><p>1、尽量减少http请求<br>2、压缩源码和静态资源<br>3、使用外部JavaScript和CSS<br>4、图片懒加载<br>5、源码优化<br>(1)代码模块化 将重复的代码封装成组件，以得到复用的效果<br>(2)写循环语句时设置key值，可以快速定位到该节点，提升性能<br>6、减少DOM操作：大量的DOM操作会导致游览器重复的渲染<br>7、首屏渲染优化<br>8、合理使用游览器缓存</p>
<h2 id="62-描述浏览器的渲染过程，DOM树和渲染树的区别"><a href="#62-描述浏览器的渲染过程，DOM树和渲染树的区别" class="headerlink" title="62.描述浏览器的渲染过程，DOM树和渲染树的区别"></a>62.描述浏览器的渲染过程，DOM树和渲染树的区别</h2><p>浏览器的渲染过程：</p>
<p>解析HTML构建 DOM(DOM树)，并行请求 css&#x2F;image&#x2F;js<br>CSS 文件下载完成，开始构建 CSSOM(CSS树)<br>CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)<br>布局(Layout)：计算出每个节点在屏幕中的位置<br>显示(Painting)：通过显卡把页面画到屏幕上<br>DOM树 和 渲染树 的区别：</p>
<p>DOM树与HTML标签一一对应，包括head和隐藏元素<br>渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性</p>
<h2 id="63-你认为什么样的前端代码是好的"><a href="#63-你认为什么样的前端代码是好的" class="headerlink" title="63.你认为什么样的前端代码是好的"></a>63.你认为什么样的前端代码是好的</h2><p>高复用低耦合，这样文件小，好维护，而且好扩展。<br>具有可用性、健壮性、可靠性、宽容性等特点<br>遵循设计模式的六大原则</p>
<h2 id="64-从浏览器地址栏输入url到显示页面的步骤"><a href="#64-从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="64.从浏览器地址栏输入url到显示页面的步骤"></a>64.从浏览器地址栏输入url到显示页面的步骤</h2><p>1、浏览器的地址栏输入URL并按下回车。</p>
<p>2、浏览器查找当前URL的DNS缓存记录。</p>
<p>3、DNS解析URL对应的IP。</p>
<p>4、根据IP建立TCP连接（三次握手）。</p>
<p>5、HTTP发起请求。</p>
<p>6、服务器处理请求，浏览器接收HTTP响应。</p>
<p>7、渲染页面，构建DOM树。</p>
<p>8、关闭TCP连接（四次挥手）。</p>
<h2 id="65-http-请求报文响应报文的格式"><a href="#65-http-请求报文响应报文的格式" class="headerlink" title="65.http 请求报文响应报文的格式"></a>65.http 请求报文响应报文的格式</h2><p>HTTP请求报文主要由请求行、请求头、空行、请求正文<br>请求行：请求行是由请求方法字段、URL字段、和HTTP协议版本字段三部分组成，它们用空格分隔。比如GET &#x2F;data&#x2F;info.html HTTP&#x2F;1.1，方法字段就是HTTP使用的请求方法。<br>请求头: 在请求头中存在cookie、客户端的主机名和端口等信息<br>空行：它的作用是通过一个空行，告诉服务器请求头部到此为止<br>请求体：可选部分，比如GET请求就没有请求正文<br>HTTP响应报文主要由状态行、响应头部、响应正文<br>状态行：状态行格式分别为协议版本、状态码、状态码描述，之间由空格分隔。其中状态码由三位数字组成，第一个数字定义了响应的类别，且有物种可能取值<br>1XX：指示信息–表示请求已接受，继续处理<br>2XX：成功–表示请求已被成功接收、理解<br>3XX：重定向<br>4XX：客户端错误<br>5XX：服务端错误<br>响应头部：与请求头部类似，为响应报文添加了一些附加信息，常见的有Server服务器的应用程序的名称和版本，Content-Type响应正文的类型等。<br>响应正文：服务器返回给服务端的响应数据</p>
<h2 id="66-Token-cookie-session-区别"><a href="#66-Token-cookie-session-区别" class="headerlink" title="66.Token cookie session 区别"></a>66.Token cookie session 区别</h2><p>Cookie由服务端生成，发送给浏览器，游览器把cookie以键值对的形式存储到本地，每次请求时网站会自动把cookie发送给服务端，每个cookie存储空间为3-4Kb，不会占据大量内存，但是每个站点的cookie数量是有限的。<br>Session 由服务端存储，是基于cookie实现的，session本身存储在服务端，但服务端会将sessionID发送给浏览器保存到cookie中，每次请求时会携带上sessionID去服务端。<br>Token是服务器经过计算生成的一串加密字符串，作为客户端进行请求的令牌，当第一次登陆时，服务器会生成一个token并返回给客户端，当客户端发起请求时携带上Token到服务端，如果验证成功就向客户端返回请求的数据。</p>
<h2 id="67-CORS跨域的原理"><a href="#67-CORS跨域的原理" class="headerlink" title="67.CORS跨域的原理"></a>67.CORS跨域的原理</h2><p>CORS是跨域资源共享，它是W3C标准，属于跨域AJAX请求的根本解决方法。<br>CORS跨域原理就是，只需要服务器端设置Access-Control-Allow-Origin。<br>服务器端对于CORS的支持，主要是通过设置Access-Control-Allow-Origin来进行的。如果游览器检测到相应的设置，就可以允许AJAX进行跨域的访问。</p>
<h2 id="68-什么是MVVM"><a href="#68-什么是MVVM" class="headerlink" title="68.什么是MVVM"></a>68.什么是MVVM</h2><p>MVVM是Model-View-ViewModel的简写，即模型层-视图层-视图模型<br>模型指的是后端传递的数据<br>视图指的是所看到的页面<br>视图模型是MVVM模式的核心，它是连接view和model的桥梁<br>MVVM采用的是双向数据绑定，view中数据变化将反映到model上，反之，model中数据变化也会自动展示在页面上，ViewModel负责把Model的数据同步到View中显示出来，也负责把View的修改同步会Model。<br>MVVM的核心思想，是关注model的变化，让MVVM框架利用自己的机制自动更新DOM，也就是所谓的数据-视图分离，数据不会影响视图。</p>
<h2 id="69-说说你对版本管理的理解？常用的版本管理工具有哪些？"><a href="#69-说说你对版本管理的理解？常用的版本管理工具有哪些？" class="headerlink" title="69.说说你对版本管理的理解？常用的版本管理工具有哪些？"></a>69.说说你对版本管理的理解？常用的版本管理工具有哪些？</h2><p>版本控制就是一种软件工程技巧，借此能在开发的过程中，确保由不同人所编辑的同一程序文件都得到同步。通过版本控制，能记录任何工程项目内各个模块的改动历程，并为每次改动编上序号，版本控制能通过这些序号将程序恢复到之前的任意一状态，简言之，你的修改只要提交到版本控制系统，基本都能找回，版本控制系统就像一台时光机器，可以让你回到任何一个时间点。<br>版本管理根据类别可以分为三类<br>1、本地版本控制系统<br>此系统较为简单，很多系统中都有内置，适合管理文本。但是不支持远程操作，因此不适合多人版本开发<br>2、集中式版本控制系统<br>适合多人团队协作开发，代码集中化管理，但是必须联网，无法单机工作<br>3、分布式版本控制系统<br>适合多人团队协作开发、代码集中化管理、可以离线工作、每一个计算机都是一个完整仓库<br>常用的版本管理工具有CVS、Git、SVN、HG</p>
<h2 id="70-说说你对Git的理解？"><a href="#70-说说你对Git的理解？" class="headerlink" title="70.说说你对Git的理解？"></a>70.说说你对Git的理解？</h2><p>Git是一个分布式版本控制软件，最初目的是为了更好地管理Linux内核开发而设计的。<br>分布式版本控制系统的客户端不只是提取最新版本的文件快照，而是把代码仓库完整的克隆下来。这么一来，如果任何一处协同工作的服务器发生故障，那么都可以用任何一个克隆出来的本地仓库恢复。<br>项目开始，只有一个原始版仓库，别的机器可以clone这个原始版本库，那么所有clone的机器，它们的版本库其实都是一样的，并没有主次之分。</p>
<p>所以在实现团队协作的时候，只要有一台电脑充当服务器的角色，其他每个人都从这个“服务器”仓库clone一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<h2 id="71-说说Git常用的命令有哪些"><a href="#71-说说Git常用的命令有哪些" class="headerlink" title="71.说说Git常用的命令有哪些"></a>71.说说Git常用的命令有哪些</h2><p>Git config 配置用户信息<br>Git init 初始化仓库<br>Git clone url 克隆代码<br>Git add . 提交全部文件到缓存区<br>Git diff 查看当前代码add后，会add哪些内容<br>Git status 查看当前分支状态<br>Git pull <state> 拉取远程仓库的分支与本地当前分支合并<br>Git commit -m “注释信息” 提交代码到本地仓库<br>Git merge &lt;分支名&gt; 合并分支<br>Git fetch 获取线上最新版信息记录，不合并<br>Git remote -v 显示所有远程仓库<br>Git push 上传本地仓库代码到远程仓库</state></p>
<h2 id="72-说说-git-发生冲突的场景？如何解决？"><a href="#72-说说-git-发生冲突的场景？如何解决？" class="headerlink" title="72.说说 git 发生冲突的场景？如何解决？"></a>72.说说 git 发生冲突的场景？如何解决？</h2><p>发生冲突的场景<br>多个分支代码合并到一个分支时<br>多个分支向同一个远程仓库分支推送<br>具体情况就是，多个分支修改了同一个文件或者多个分支修改了同一个文件的名称。<br>当本地修改的文件和目标远程仓库的同一个文件都有修改，这时，无论是pull&#x2F;push&#x2F;merge时都会发生冲突。<br>解决方法：<br>修改文件之前先git pull 获取远程最新的代码，同步完之后在对代码进行修改。</p>
<h2 id="73-前端工程化的特点"><a href="#73-前端工程化的特点" class="headerlink" title="73.前端工程化的特点"></a>73.前端工程化的特点</h2><p>前端工程化可以分成四个方面来说，分别为模块化、组件化、规范化和自动化。</p>
<p>模块化<br>模块化是指将一个文件拆分成多个相互依赖的文件，最后进行统一的打包和加载，这样能够很好的保证高效的多人协作。其中包含</p>
<p>JS 模块化：CommonJS、AMD、CMD 以及 ES6 Module。<br>CSS 模块化：Sass、Less、Stylus、BEM、CSS Modules 等。其中预处理器和 BEM 都会有的一个问题就是样式覆盖。而 CSS Modules 则是通过 JS 来管理依赖，最大化的结合了 JS 模块化和 CSS 生态，比如 Vue 中的 style scoped。<br>资源模块化：任何资源都能以模块的形式进行加载，目前大部分项目中的文件、CSS、图片等都能直接通过 JS 做统一的依赖关系处理。<br>组件化<br>不同于模块化，模块化是对文件、对代码和资源拆分，而组件化则是对 UI 层面的拆分。</p>
<p>通常，我们会需要对页面进行拆分，将其拆分成一个一个的零件，然后分别去实现这一个个零件，最后再进行组装。 在我们的实际业务开发中，对于组件的拆分我们需要做不同程度的考量，其中主要包括细粒度和通用性这两块的考虑。 对于业务组件，你更多需要考量的是针对你负责业务线的一个适用度，即你设计的业务组件是否成为你当前业务的 “通用” 组件。</p>
<p>规范化<br>正所谓无规矩不成方圆，一些好的规范则能很好的帮助我们对项目进行良好的开发管理。规范化指的是我们在工程开发初期以及开发期间制定的系列规范，其中又包含了</p>
<p>项目目录结构<br>编码规范：对于编码这块的约束，一般我们都会采用一些强制措施，比如 ESLint、StyleLint 等。<br>联调规范<br>文件命名规范<br>样式管理规范：目前流行的样式管理有 BEM、Sass、Less、Stylus、CSS Modules 等方式。<br>git flow 工作流：其中包含分支命名规范、代码合并规范等。<br>定期 code review … 等等<br>自动化<br>从最早先的 grunt、gulp 等，再到目前的 webpack、parcel。这些自动化工具在自动化合并、构建、打包都能为我们节省很多工作。而这些只是前端自动化其中的一部分，前端自动化还包含了持续集成、自动化测试等方方面面。</p>
<p>以上就是我所了解的前端工程化，以工程的角度去理解我们的web前端。工程是工程，而不是某项技术。</p>
<h2 id="74为什么-GUI-渲染线程为什么与JS-引擎线程互斥"><a href="#74为什么-GUI-渲染线程为什么与JS-引擎线程互斥" class="headerlink" title="74为什么 GUI 渲染线程为什么与JS 引擎线程互斥"></a>74为什么 GUI 渲染线程为什么与JS 引擎线程互斥</h2><p>这是由于 S 是可以操作 DOM 的，如果同时修改元素属性并同时染界面(即 S线程和 UI线程同时运行)<br>。那么渲沈线程前后获得的元素就可能不一致了<br>。因此，为了防止渲染出现不可预期的结果，浏览器设定 GUI渲染线程和]S引擎线程为互斥关系<br>。Is引擎线程执行完后&#x3D;》GUI 染页面操作<br>当IS引擎线程执行时 GUI渲染线程会被挂起，GUI更新则会被保存在一个队列中等待S引擎线程空闲时立即被执行</p>
]]></content>
  </entry>
  <entry>
    <title>对盒子模型的理解</title>
    <url>/2019/09/25/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="1-什么是盒子模型？"><a href="#1-什么是盒子模型？" class="headerlink" title="1.什么是盒子模型？"></a>1.什么是盒子模型？</h2><p>当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）</p>
<p>一个盒子由四个部分组成：content、padding、border、margin<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/a89c2fdd216346b8bfa0cf681cec0154.png" alt="在这里插入图片描述"><br>如上图所示 </p>
<ul>
<li>Margin(外边距) - 清除边框外的区域，外边距是透明的。 这个区域无法放别的元素 </li>
<li>Border(边框) - 围绕在内边距和内容外的边框。 可以设置 粗细  样式  颜色         <em>具体如何设置<a href="https://www.runoob.com/css/css-border.html">详情</a> 点击详情</em></li>
<li>Padding(内边距) - 清除内容周围的区域，内边距是透明的。不可以是负值  会受background-color 影响</li>
<li>Content(内容) - 盒子的内容，显示文本和图像。</li>
</ul>
<p>content的宽度加上padding + border + margin 的宽度也就是我们这个盒子的一个占地宽度  高同样 </p>
<h2 id="2-盒子的区分"><a href="#2-盒子的区分" class="headerlink" title="2.盒子的区分"></a>2.盒子的区分</h2><p>盒子分为  W3C 标准盒子模型 和 IE 怪异盒子模型<br>默认情况下 ，我们说的盒子模型通常讲的就是W3C标准盒子 </p>
<p>在标准盒子模型中 ：</p>
<pre><code>盒子总宽度 = width + padding + border + margin;
盒子总高度 = height + padding + border + margin
也就是，width/height 只是内容高度，不包含 padding 和 border值
</code></pre>
<p>我们在设置宽高的时候设置的是内容  盒子具体占地大小 需要计算  </p>
<p>怪异盒子模型 ：</p>
<pre><code>盒子总宽度 = width + margin;
盒子总高度 = height + margin;
也就是，width/height 包含了 padding和 border值
</code></pre>
<p>这个是使用了css 中 <strong>box-sizing</strong>  之后的效果，  box-sizing 定义了引擎应该如何计算一个元素的总宽度和总高度</p>
<ul>
<li>content-box 默认值，元素的 width&#x2F;height 不包含padding，border，与标准盒子模型表现一致   </li>
<li>border-box 元素的 width&#x2F;height 包含 padding，border，与怪异盒子模型表现一致</li>
<li>inherit 指定 box-sizing 属性的值，应该从父元素继承</li>
</ul>
<p>当我们想使用怪异盒子的时候在我们的box-sizing属性中给他一个borer-box 就可以实现了 </p>
]]></content>
      <categories>
        <category>通用知识</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>valine 实现博客评论功能</title>
    <url>/2022/03/29/valine%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE/valine%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="Valine访问被api域名白名单拒绝"><a href="#Valine访问被api域名白名单拒绝" class="headerlink" title="Valine访问被api域名白名单拒绝"></a>Valine访问被api域名白名单拒绝</h1><p>今天我修改之前的博客，出现了一个valine访问被api域名白名单拒绝的问题，我忘记了 Valine 的使用流程了，记录一下 。为了实现博客的评论功能，我选择使用的是LeanCloud 的一站式后端服务。<br>    先说解决办法 ：<br>    打开 <a href="https://console.leancloud.cn/">LeanCloud 链接 </a><br>    滑到最下面打开   设置-&gt;安全中心  找到 Web安全域名<br>    复制你现在用的域名放在里面就好了<br>   <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/03/29/valine%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE/valine%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE/myblog\source_posts\valine拒绝访问\image-20230331162754400.png" alt="image-20230331162754400"></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>react生成图片验证码</title>
    <url>/2020/10/21/scrip%E6%A0%87%E7%AD%BE%E4%B8%ADdefer%20%E5%92%8C%20async%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>使用uni-app 扩展插件实现通讯录列表</title>
    <url>/2019/10/27/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2019/10/27/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/myblog\source_posts\使用uni扩展插件实现通讯录列表\image-20230331161926026.png" alt="image-20230331161926026"></p>
<p>使用uniapp 的扩展插件实现通讯录列表  实现有头像显示头像没有头像 显示名称第一个字</p>
<p>首先需要去官网下载扩展的插件包</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2019/10/27/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/myblog\source_posts\使用uni扩展插件实现通讯录列表\image-20230331162438885.png" alt="image-20230331162438885"></p>
<p>然后进行导入</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2019/10/27/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/myblog\source_posts\使用uni扩展插件实现通讯录列表\image-20230331162855673.png" alt="image-20230331162438885"></p>
<p>我们就可以在uni_modules 中看到这个扩展得插件了  打开uni-indexed-list的vue文件  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2019/10/27/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/myblog\source_posts\使用uni扩展插件实现通讯录列表\image-20230331163101734.png" alt="image-20230331162438885"></p>
<p>通过这里我们发现 数据是通过options 传递的 我们找到options</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2019/10/27/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/myblog\source_posts\使用uni扩展插件实现通讯录列表\image-20230331163226552.png" alt="image-20230331162438885"></p>
<p>这里就是我们拿到调用页面传过去的数据  做数据处理的地方 通过我们想要传递的数据进行修改 </p>
<p>接下来修改uni-indexed-list-item的vue文件 找到这里</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2019/10/27/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/myblog\source_posts\使用uni扩展插件实现通讯录列表\image-20230331163545322.png" alt="image-20230331162438885"></p>
<p>这里是页面显示的样式的代码 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2019/10/27/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/myblog\source_posts\使用uni扩展插件实现通讯录列表\image-20230331163657923.png" alt="image-20230331162438885"></p>
<p>这一行就是修改每条信息的内容 我这里是添加了一个图片 和一个div 通过判断数据是否有img 进行显示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2019/10/27/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/myblog\source_posts\使用uni扩展插件实现通讯录列表\image-20230331163928921.png" alt="image-20230331162438885"></p>
<p>调用页面的数据这么传递</p>
<p>这样页面的一个样式就实现了 ，就是开头的那个样式</p>
<p>到这里就基本上完成了但是我看着这个数据不是很舒服 这样看来岂不是我每次添加一个数据都要进行分类才可以添加我想要这个样子的数据</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2019/10/27/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/%E4%BD%BF%E7%94%A8uni%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%97%E8%A1%A8/myblog\source_posts\使用uni扩展插件实现通讯录列表\image-20230406093948131.png" alt="image-20230406093948131"></p>
<p>于是我对数据进行了一个简单的处理</p>
<p>这个是把字符串变成拼音的 可以自己写一个也可以用插件 我用的插件需要</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i pinyin --save</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">toPinyin(str) &#123;</span><br><span class="line">			if (!str) return &#x27;&#x27;;</span><br><span class="line">			return pinyin(str, &#123;</span><br><span class="line">				style: pinyin.STYLE_NORMAL, // 设置拼音风格</span><br><span class="line">				heteronym: false // 是否启用多音字模式</span><br><span class="line">			&#125;).join(&#x27;&#x27;);</span><br><span class="line">		&#125;,</span><br></pre></td></tr></table></figure>



<p>最后定义一个方法在数据初始化的时候调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getfriendslist() &#123;</span><br><span class="line">			const friendlist = &#123;&#125;</span><br><span class="line">			this.friends.forEach(i =&gt; &#123;</span><br><span class="line">			//这里是提取字段的一个字母</span><br><span class="line">			let first = this.toPinyin(i.name).substring(0, 1).toUpperCase();</span><br><span class="line">			//通过正则判断是否是26个字母之内的不是的就属于 # 类 然后进行分类</span><br><span class="line">				if(!(/^[a-zA-Z]+$/.test(first)))&#123;first=&#x27;#&#x27;&#125;</span><br><span class="line">				</span><br><span class="line">				if (friendlist[first]) &#123;</span><br><span class="line">					friendlist[first].push(i);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					friendlist[first] = [i];</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			// 	 /**</span><br><span class="line">			// 	  * sort 默认是根据每个元素的 ASCII 码进行排序</span><br><span class="line">			// 	  * 对于数字可以直接比较 但如果是字符就没有意义</span><br><span class="line">			// 	  * 规则：如果 a - b 是负数，也就是 a &lt; b , 那么 a 在前面，返回-1。</span><br><span class="line">			// 	  * 如果 a - b 是正数，也就是 a &gt; b , 那么 b 在前面，返回 1</span><br><span class="line">			// 	  * 如果两个相等，那就啥也不干，返回 0</span><br><span class="line">			// 	  */</span><br><span class="line">				</span><br><span class="line">                </span><br><span class="line">                //进行排序</span><br><span class="line">				 let keys = Object.keys(friendlist).sort((a, b) =&gt; (a &lt; b ? -1 : a &gt; b ? 1 : 0));</span><br><span class="line">					let arr = []</span><br><span class="line">					for (let i in friendlist)&#123;</span><br><span class="line">                	// 改变数据</span><br><span class="line">						arr.push(&#123;</span><br><span class="line">							letter:i,</span><br><span class="line">							data:friendlist[i]</span><br><span class="line">						&#125;)</span><br><span class="line">					&#125;</span><br><span class="line">					//  把改变好的数据复制给要遍历的数组</span><br><span class="line">					this.list = arr</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
</search>
